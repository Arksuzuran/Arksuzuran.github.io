<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA2023春OS课程LAB4实验报告 | H1kari's Blog</title><meta name="author" content="H1kari"><meta name="copyright" content="H1kari"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab4实验报告ThinkingThinking 4.1（1） 内核在保存现场的时候是如何避免破坏通用寄存器的？  ​		首先，内核保存现场就在异常分发代码的第一条语句处，使用宏SAVE_ALL来保存现场。这样避免了异常分发代码中其他语句对于寄存器的修改（例如mfc0 t0, CP0_CAUSE修改了t0寄存器） ​		在SAVE_ALL宏之中，因为要将栈寄存器sp设置为内核栈地址，因此先将sp寄">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA2023春OS课程LAB4实验报告">
<meta property="og:url" content="http://example.com/2023/08/20/OSlab-report-4/index.html">
<meta property="og:site_name" content="H1kari&#39;s Blog">
<meta property="og:description" content="Lab4实验报告ThinkingThinking 4.1（1） 内核在保存现场的时候是如何避免破坏通用寄存器的？  ​		首先，内核保存现场就在异常分发代码的第一条语句处，使用宏SAVE_ALL来保存现场。这样避免了异常分发代码中其他语句对于寄存器的修改（例如mfc0 t0, CP0_CAUSE修改了t0寄存器） ​		在SAVE_ALL宏之中，因为要将栈寄存器sp设置为内核栈地址，因此先将sp寄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/default_cover_3.png">
<meta property="article:published_time" content="2023-08-19T16:45:27.347Z">
<meta property="article:modified_time" content="2023-08-19T16:53:54.960Z">
<meta property="article:author" content="H1kari">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default_cover_3.png"><link rel="shortcut icon" href="/img/hfavicon.png"><link rel="canonical" href="http://example.com/2023/08/20/OSlab-report-4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA2023春OS课程LAB4实验报告',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-20 00:53:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover_3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="H1kari's Blog"><span class="site-name">H1kari's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA2023春OS课程LAB4实验报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T16:45:27.347Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-19T16:53:54.960Z" title="更新于 2023-08-20 00:53:54">2023-08-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA2023春OS课程LAB4实验报告"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab4实验报告"><a href="#Lab4实验报告" class="headerlink" title="Lab4实验报告"></a>Lab4实验报告</h1><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><blockquote>
<p>内核在保存现场的时候是如何避免破坏通用寄存器的？</p>
</blockquote>
<p>​		首先，内核保存现场<strong>就在异常分发代码的第一条语句处</strong>，使用宏SAVE_ALL来保存现场。这样<strong>避免了异常分发代码中其他语句对于寄存器的修改</strong>（例如<code>mfc0 t0, CP0_CAUSE</code>修改了<code>t0</code>寄存器）</p>
<p>​		在SAVE_ALL宏之中，因为要将栈寄存器<code>sp</code>设置为内核栈地址，因此<strong>先将<code>sp</code>寄存器保存在<code>k0</code>寄存器中，再修改<code>sp</code>至<code>KSTACKTOP-TF_SIZE</code><strong>。随后</strong>继续使用<code>k0</code>寄存器保存cp0中寄存器的值</strong>。然后依次保存从<code>zero</code>寄存器到<code>ra</code>寄存器的值。至于**<code>k0</code>寄存器，它不在用户进程中使用，而是专门用于异常处理，因此k0的值变化是无所谓的**。</p>
<blockquote>
<p>R3000手册中对于<code>k0</code>和<code>k1</code>寄存器的部分说明</p>
<p>two registers ($k0, $k1; register conventions are explained in chapter 2) are reserved so that interrupt&#x2F;trap routines can ‘‘bootstrap’’ themselves – it is impossible to do anything on a MIPS CPU without using some registers. For a program running in any system which takes interrupts or traps, the values of these registers may change at any time, and thus should not be used.</p>
</blockquote>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><blockquote>
<p>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall 留下的信息吗？</p>
</blockquote>
<p>​		<strong>只有<code>a0</code>不可以。</strong></p>
<p>​		系统调用的异常号是8，将进入的首个关于系统调用的内核调用函数是<code>do_syscall</code>，然后再进入对应的实际处理函数。</p>
<p>​		进入<code>do_syscall</code>的调用链是：<code>exc_gen_entry</code>-&gt;<code>handle_syscall</code>-&gt;<code>do_syscall</code>。在这个调用过程中，**<code>a0</code>寄存器被用于向<code>do_syscall</code>传递参数<code>struct Trapframe *tf</code>，其值被修改为<code>KSTACKTOP-TF_SIZE</code>，而非我们需要的<code>sysno</code><strong>。</strong>而<code>a1</code>,<code>a2</code>,<code>a3</code>寄存器尚未修改，可以得到<code>msyscall</code>的信息。**</p>
<h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><blockquote>
<p>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样 的参数的？		</p>
</blockquote>
<p>​		在调用<code>msyscall</code>的<code>syscall</code>开头函数的参数列表中，<strong>首个参数用于控制调用哪个<code>sys</code>开头函数，其余参数列表（即列表[1:]）则与<code>sys</code>开头函数的参数列表完全一致。且在调用过程中，经过了<code>do_syscall</code>的处理，一一对应地传入了<code>sys</code>开头函数</strong>。</p>
<h4 id="（4）"><a href="#（4）" class="headerlink" title="（4）"></a>（4）</h4><blockquote>
<p>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变 化是什么？</p>
</blockquote>
<p>​		在<code>do_syscall</code>中修改了<code>EPC</code>寄存器的值。这样可以使得返回用户态后从下一条语句开始执行（即msyscall中的<code>jr ra</code>语句）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;cp0_epc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>​		在<code>do_syscall</code>中还会修改<code>v0</code>寄存器的值。这样可以将具体的处理函数的返回值传递回用户进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br></pre></td></tr></table></figure>

<p>​		此外在<code>sys_exofork</code>中，对于子进程还特地将<code>v0</code>寄存器修改为0，以通过返回值来区分父子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_exofork</span><br></pre></td></tr></table></figure>



<h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><blockquote>
<p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id !&#x3D; envid 的情况？如果没有这步判断会发生什么情况？</p>
</blockquote>
<p>​		因为<strong>不同的<code>envid</code>可以对应一个<code>ENVX(envid)</code>，如果<code>envid</code>对应进程其实已销毁或未分配，函数能够正确报错且同<code>ENVX(envid)</code>的正常进程不受影响</strong>。</p>
<p>​		e是通过该行代码进行获取：**<code>e = &amp;envs[ENVX(envid)];</code>。然而这仅使用了<code>envid</code>后11位的信息，要唯一确定一个进程，还需要确认前21位**，因此就需要进行这样的判断。</p>
<p>​		如果没有这样的判断，如果传入的<code>envid</code>其实是已销毁或未分配的进程，那么在<code>!checkperm</code>的场合下，函数可能会返回当前<code>envid</code>末11位为<code>ENVX(envid)</code>的进程控制块，造成不可预料的错误。</p>
<p>​		</p>
<h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><blockquote>
<p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern&#x2F;env.c 文件 中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。</p>
</blockquote>
<p>​		最主要的作用是<strong>保留<code>envid</code>为0的情况，以便于：（1）用于代指<code>curenv</code>，便于无法获取<code>curenv</code>的用户态<code>syscall_*</code>函数进行传参。（2）在fork()函数中以0返回值来标识子进程</strong>。</p>
<p>​		在<code> envid2env()</code>函数中，当<code>envid</code>为0时会直接返回当前进程，将<code>envid</code>为0赋予了当前进程的含义。进一步，调用了<code> envid2env()</code>的<code>sys_*</code>系函数亦可以允许<code>envid</code>为0来充当参数。最后，根据Thinking 4.1（3）的分析，<strong>用户态下当然也可以给<code>envid</code>参数传入0来代指<code>curenv</code>。而<code>curenv</code>是内核数据结构，尚未暴露给用户进程。这可能就是”0代指<code>curenv</code>“机制的意义之一</strong>。</p>
<p>​		此外，对于成功执行的<code>syscall_exofork()</code>，<code>fork</code>函数，父进程中返回子进程的<code>id</code>，子进程中返回0，由于<code>id</code>不为0，所以就可以根据返回值有效地区分父子进程。</p>
<h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><blockquote>
<p>关于 fork 函数的两个返回值，下面说法正确的是：</p>
<p> A、fork 在父进程中被调用两次，产生两个返回值 </p>
<p>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 </p>
<p>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 </p>
<p>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值	</p>
</blockquote>
<h4 id="选择C"><a href="#选择C" class="headerlink" title="选择C"></a>选择C</h4><p>​		A.错误。根据代码可知只调用了一次。如果仅在最开始的父进程内调用了两次，那最终应当有共3个进程。</p>
<p>​		B. D.错误。fork仅在父进程中被调用，子进程只是继承了父进程的运行现场，在被<code>env_run</code>唤醒后，根据epc寄存器的值返回用户态，最终从<code>syscall_exofork()</code>中携带返回值0返回，这不能称作是调用了一次fork。如果子进程调用了fork，那最终应当有共3个进程。</p>
<h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><blockquote>
<p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪 些用户空间页应该映射，哪些不应该呢？请结合 kern&#x2F;env.c 中 env_init 函数进行的页 面映射、include&#x2F;mmu.h 里的内存布局图以及本章的后续描述进行思考。</p>
</blockquote>
<p>​		<strong><code>UTEXT</code>到<code>USTACKTOP</code>之间的页面</strong>需要保护。下面分析其余页面无需保护的原因：</p>
<p>​		<code>UTEXT</code>到<code>UCOW</code>之间的页面仅在<code>cow_entry</code>函数处理页写入异常时，被用作临时存放页面内容，每一次都会使用<code>syscall_mem_alloc</code>来当场指定perm并分配物理页，并在<code>page_walk</code>函数中被加上<code>PTE_D</code>标志。此外，该段空间在进程正常运行过程中也不会使用，因此无需保护。不过这部分页面即使被写时复制保护也无所谓，反正都要在<code>cow_entry</code>中现场alloc()。</p>
<p>​		<code>UTEMP</code>到<code>UCOW</code>之间的页面目前应该还没有使用过，但根据<code>mmu.h</code>中“ reversed for temporary ”的说明可以猜测，其与<code>UTEXT</code>到<code>UCOW</code>应该类似，无需保护。</p>
<p>​		<code>0</code>到<code>UTEMP</code>之间的页面无法使用，无需保护。</p>
<p>​		<code>USTACKTOP</code>到<code>UXSTACKTOP</code>间的页面用作用户态异常处理栈，<strong>本身就已经被用于实现页写入异常的类似”重入”机制，如果再加以写时复制保护，可能又会触发页写入异常，从而导致死循环</strong>。</p>
<p>​		<code>UXSTACKTOP</code>到<code>ULIM</code>间的页面，进程不具备可写权限，无需保护。</p>
<h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><blockquote>
<p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参 考 user&#x2F;include&#x2F;lib.h 中的相关定义，思考并回答这几个问题： </p>
</blockquote>
<blockquote>
<p>vpt 和 vpd 的作用是什么？怎样使用它们？ </p>
</blockquote>
<p>​		<code>vpt</code>和<code>vpd</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure>

<p>​		<code>vpt</code>是进程页表区域在kuseg的基地址，<code>vpd</code>是进程页目录在kuseg的基地址。其<strong>作用是方便用户态下直接查阅进程自己的页表的指定项</strong>。</p>
<p>​		<strong>用法是直接作为指向kuseg中页表区基地址、页目录基地址的一级指针使用</strong>，可以很方便地直接访问到指定的页表项。例如：<code>vpt[VPN(va)]</code>就是访问<code>va</code>对应的二级页表项。</p>
<blockquote>
<p>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</p>
</blockquote>
<p>​		<strong>根本原因是，早在<code>env_setup_vm</code>函数中我们就已经实现了页目录自映射</strong>：<code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>。详细的废话如下：</p>
<p>​		当我们通过这种方式去访问<code>UVPT</code>到<code>ULIM</code>之间的页表区内的kuseg地址<code>va</code>时，可能的访存调用路径有下面两条：</p>
<p>​		（1）首次访问时会触发TLB MISS，在查页表重填TLB的过程中，会调用到函数<code>_do_tlb_refill</code>来查询<code>va</code>对应的页表项，查询或者<code>passive_alloc</code>的过程中通过<code>page_lookup</code>等函数最终调用了<code>page_walk</code>函数。</p>
<p>​		（2）直接调用<code>syscall_mem_map</code>（或者ummap），也会在<code>sys_mem_map</code>（或者ummap）中通过<code>page_lookup</code>等函数最终调用了<code>page_walk</code>函数。</p>
<p>​		容易看到，所有对于<code>va</code>的处理最终都落在了<code>page_walk</code>上，该函数的作用是处理页表查询逻辑。</p>
<p>​		在**<code>page_walk</code>函数中，根据<code>va</code>定位到的页目录项恰好就是<code>pgdir[PDX(va)]</code>，根据自映射，这个页目录项对应的二级页表恰好就是页目录自己**。之后的过程就和查询普通二级页表一样了，最终可以实现对自身页表的存取。</p>
<blockquote>
<p>它们是如何体现自映射设计的？</p>
</blockquote>
<p>​		在上一问中和其他作业、报告中已经回答过详细的过程，简要的总结如下：</p>
<p>​		自映射就是根据页表线性映射的规则，<strong>在特定的页目录项内填入页目录自身的地址，以实现页表对于页表区自身所在的虚拟地址空间的管理</strong>。而**<code>vpt</code>和<code>vpd</code>恰恰就是用于访问页表区自己，这个访问的过程体现了自映射设计的作用**。</p>
<p>​		</p>
<blockquote>
<p>进程能够通过这种方式来修改自己的页表项吗？</p>
</blockquote>
<p>​		<strong>当然可以，否则我们的duppage等函数就无法实现。不过不能由进程自己直接修改，而是要借助系统调用</strong>。</p>
<p>​		例如我们直接写<code>vpt[17900] = 21400</code>是非法的，因为用户态下进程对于页表区不具有写权限。但借助<code>syscall_mem_map</code>和<code>syscall_mem_unmap</code>来唤起系统调用，则可以在进入内核态后最终使用<code>page_insert</code>来修改目标页表项。</p>
<h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><blockquote>
<p>在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：</p>
</blockquote>
<blockquote>
<p>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</p>
</blockquote>
<p>​		当<strong>在用户态下处理页写入异常时，如果又触发了页写入异常</strong>，就会出现这种异常重入。</p>
<p>​		</p>
<blockquote>
<p>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</p>
</blockquote>
<p>​		因为在用户空间的页写入异常处理函数<code>cow_entry</code>中<strong>要使用<code>Trapframe </code>作为系统调用的参数，以处理缺页中断</strong>。</p>
<p>​		例如在函数的最后，要用异常的现场<code>tf</code>作为参数，调用不返回的<code>syscall_set_trapframe</code>以恢复保存好的现场，使得用户程序恢复运行。</p>
<h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><blockquote>
<p>在用户态处理页写入异常，相比于在内核态处理有什么优势？</p>
</blockquote>
<p>​		在用户态处理页写入异常是微内核的设计。优势主要在于：</p>
<ul>
<li>提高了内核安全性。处理程序作为普通用户程序，即使崩溃也不会影响整个系统的稳定。</li>
<li>移植性高，只要实现了相应的系统调用，即可实现移植。</li>
<li>提高了并发性，异常处理的过程也会受到时钟中断的影响，不会长时间占用CPU。</li>
</ul>
<h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><blockquote>
<p>请思考并回答以下几个问题：</p>
</blockquote>
<blockquote>
<p>为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</p>
</blockquote>
<p>​		因为<strong>父进程的虚拟地址空间可能存在没有<code>PTE_D</code>的页面，需要确保已设置好页写入异常的处理函数</strong>。倘若在<code>syscall_exofork</code>的过程中触发<code>TLB MOD</code>，则经过<code>do_tlb_mod</code>处理后程序会跳转到意外的地址，造成不可预料的后果。</p>
<blockquote>
<p>如果放置在写时复制保护机制完成之后会有怎样的效果？</p>
</blockquote>
<p>​		此时程序的用户栈被置入了写时复制保护，而执行<code>try(syscall_set_tlb_mod_entry(0, cow_entry))</code>就会修改用户栈，从而<strong>会立即触发<code>TLB MOD</code>。而在内核态下<code>do_tlb_mod</code>会修改现场的EPC寄存器至尚未设置好的<code>curenv-&gt;env_user_tlb_mod_entry</code>处，造成不可预料的后果</strong>。</p>
<h2 id="二、难点总结"><a href="#二、难点总结" class="headerlink" title="二、难点总结"></a>二、难点总结</h2><h3 id="1-系统调用的过程"><a href="#1-系统调用的过程" class="headerlink" title="1.系统调用的过程"></a>1.系统调用的过程</h3><p>​		系统调用是一种机制。当用户进程需要执行只能由内核完成的操作时（例如操作硬件，动态分配内存，进程间通信），可以<strong>由进程自己自己引发特定异常以陷入内核态，内核则在异常处理函数中，根据寄存器状态来调用用户进程要求的处理函数</strong>，从而安全地为用户进程提供这些首先的系统级操作。</p>
<p>​		系统调用的流程如下：</p>
<h4 id="1-1-syscall-系列函数"><a href="#1-1-syscall-系列函数" class="headerlink" title="1.1 syscall_*系列函数"></a>1.1 <code>syscall_*</code>系列函数</h4><h5 id="1-1-1-函数作用总结"><a href="#1-1-1-函数作用总结" class="headerlink" title="1.1.1 函数作用总结"></a>1.1.1 函数作用总结</h5><p>​		该系列函数<strong>与用户进程请求的内核态处理函数一一对应：名称相似，参数列表一致</strong>。</p>
<p>​		<strong>在用户态调用这些函数，就能够请求相应系统调用</strong>，并最终从这些函数返回。</p>
<h5 id="该系列函数的作用主要是：在陷入内核态前，安置好传递给内核态的参数。"><a href="#该系列函数的作用主要是：在陷入内核态前，安置好传递给内核态的参数。" class="headerlink" title="该系列函数的作用主要是：在陷入内核态前，安置好传递给内核态的参数。"></a>该系列函数的作用主要是：在陷入内核态前，安置好传递给内核态的参数。</h5><h5 id="1-1-2-栈帧"><a href="#1-1-2-栈帧" class="headerlink" title="1.1.2 栈帧"></a>1.1.2 栈帧</h5><p><img src="C:\Users\24712\AppData\Roaming\Typora\typora-user-images\image-20230423171450483.png" alt="image-20230423171450483"></p>
<blockquote>
<p>讲解视频中<code>syscall_mem_map</code>的反汇编结果</p>
</blockquote>
<p>​		以上这么多行汇编代码全部由<code>return</code>一句编译而成，其原理是MIPS调用规范中的栈帧机制。</p>
<p>​		栈存在于一段从高地址向低地址增长的指定空间中。在用户态下，是<code>USTACKTTOP</code>（普通用户栈）或<code>UXSTACKTOP</code>（用户异常栈）下的一个虚拟页的空间。</p>
<p>​		每一个函数在调用时，都会在其调用者的栈底下再分配一段栈空间，于调用结束时弹栈回收，这段空间就叫做栈帧。栈帧中存储着函数自己的局部变量，返回地址，以及函数自己要传给另一个被调用函数的参数。</p>
<p><img src="C:\Users\24712\AppData\Roaming\Typora\typora-user-images\image-20230423212701619.png" alt="image-20230423212701619"></p>
<blockquote>
<p>指导书中，<code>syscall_*</code>系列函数的栈帧栈底和寄存器的示意图。</p>
</blockquote>
<h5 id="1-1-3-传参原理"><a href="#1-1-3-传参原理" class="headerlink" title="1.1.3 传参原理"></a>1.1.3 传参原理</h5><p>​		<code>msyscall</code>函数是没有栈帧的，我们的工作是<strong>在调用<code>msyscall</code>自陷之前，设置好寄存器和栈帧。在跳转到异常分发程序后，我们上来就会运行<code>SAVE_ALL</code>，以保存这些参数</strong>。</p>
<p>​		栈帧中的第五个以后参数的传递机制是：（1）<strong>从栈底往上先预留前四个参数的空间</strong>（2）然后<strong>顺次在栈帧中保留其余参数</strong>。</p>
<p>​		需要注意的是传递的第一个参数，这是<code>do_syscall</code>中区分所需调用内核函数的唯一标志。</p>
<p>​		指导书中讲解的已经非常详细，附上指导书原文：</p>
<blockquote>
<p>MIPS 寄存器使用规范中指出，<strong>寄存器 $a0-$a3 用于存放函数调用的前四个参数 （但在栈中仍然需要为其预留空间），剩余的参数仅存放在栈中</strong>。</p>
<p>以我们的 MOS 操作系统为例， msyscall 函数一共有 6 个参数，前 4 个参数会被 syscall_* 的函数分别存入 $a0-$a3 寄存器 （寄存器传参的部分）同时<strong>栈帧底部保留 16 字节的空间（不要求存入参数的值），后 2 个参数只 会被存入在预留空间之上的 8 字节空间内（没有寄存器传参），于是总共 24 字节的空间用于参 数传递</strong>。C 代码中的这些调用过程会由编译器自动编译为汇编代码，而我们在内核中则需要显式 地从保存的用户上下文中获取函数的参数值。</p>
</blockquote>
<h4 id="1-2-msyscall函数"><a href="#1-2-msyscall函数" class="headerlink" title="1.2 msyscall函数"></a>1.2 <code>msyscall</code>函数</h4><p>​		这是一个叶函数，没有栈帧，不会破坏刚刚精心设置好的现场。</p>
<p>​		该函数首先执行<code>syscall</code>指令自陷：触发8号异常，使得系统将会进入异常分发函数。</p>
<p>​		系统调用完成后，**回到用户态的首个指令即是该函数的第二条语句<code>jr ra</code>**，这是epc寄存器被+4的结果。</p>
<h4 id="1-3-异常分发入口"><a href="#1-3-异常分发入口" class="headerlink" title="1.3 异常分发入口"></a>1.3 异常分发入口</h4><p>​		该段代码已经在lab3报告中分析过了，其流程简述如下：</p>
<p>​		首先执行<code>SAVE_ALL</code>汇编宏，这将会启用内核异常栈，并将现场保存到栈顶的<code>struct Trapfram</code>结构体中。</p>
<p>​		随后取出CAUSE寄存器的第2至6位（从第2位开始设置的原因是，地址的长度是4字节，所有这样<code>exception_handlers + CAUSE寄存器的值 &amp; 0x7c</code>正好就是所求地址），将这五位组成的二进制数作为数组下标i，跳转到已注册的异常处理函数处（地址是<code>exception_handlers[i]</code>）。</p>
<h4 id="1-4-handle-syscall函数"><a href="#1-4-handle-syscall函数" class="headerlink" title="1.4 handle_syscall函数"></a>1.4 <code>handle_syscall</code>函数</h4><p>​		该函数是通过汇编宏<code>BUILD_HANDLER sys do_syscall</code>声明的，先将内核异常栈顶的<code>tf</code>结构体地址作为<code>do_syscall</code>的参数，然后调用<code>do_syscall</code>，最后调用<code>ret_from_exception</code>恢复现场。</p>
<h4 id="1-5-do-syscall函数"><a href="#1-5-do-syscall函数" class="headerlink" title="1.5 do_syscall函数"></a>1.5 <code>do_syscall</code>函数</h4><p>​		该函数的作用是根据栈帧传参规则取出来自用户态的参数，设置好返回所用的寄存器，并根据调用号使用取出的参数来调用相应的处理函数。</p>
<h4 id="1-6-ret-from-exception函数"><a href="#1-6-ret-from-exception函数" class="headerlink" title="1.6 ret_from_exception函数"></a>1.6 <code>ret_from_exception</code>函数</h4><p>​		该函数会调用<code>RESTORE_SOME</code>汇编宏，根据<code>tf</code>的值恢复寄存器现场，操作SR寄存器的二重栈，最终返回用户态。</p>
<h3 id="2-系统调用的内核处理函数"><a href="#2-系统调用的内核处理函数" class="headerlink" title="2.系统调用的内核处理函数"></a>2.系统调用的内核处理函数</h3><p>​		涉及到物理空间分配或者虚拟地址映射的函数，多使用<code>page_*</code>系函数实现：</p>
<ul>
<li><code>page_lookup</code>：在指定虚拟地址空间下查询<code>va</code>映射的物理页</li>
<li><code>page_insert</code>：在指定进程的指定虚拟地址空间下将<code>va</code>以<code>perm</code>映射到指定物理页</li>
<li><code>page_remove</code>：在指定虚拟地址空间下删除<code>va</code>可能存在的映射关系。</li>
</ul>
<p>​		将<code>envid</code>转换为进程控制块，则使用<code>envid2env</code>函数取得。</p>
<p>​		以下函数其实内部逻辑相对简单，都是简单的赋值或上述函数的封装组合，因此不分析细节，只总结功能：</p>
<h4 id="2-1-is-illegal-va-u-long-va"><a href="#2-1-is-illegal-va-u-long-va" class="headerlink" title="2.1 is_illegal_va(u_long va)"></a>2.1 <code>is_illegal_va(u_long va)</code></h4><p>​		该函数判断来自内核请求的<code>va</code>地址是否合法，即是否处于<code>UTEMP</code>到<code>UTOP</code>之间。这段空间是用户态下具有可写权限的区域。</p>
<h4 id="2-2-envid2env-u-int-envid-struct-Env-penv-int-checkperm"><a href="#2-2-envid2env-u-int-envid-struct-Env-penv-int-checkperm" class="headerlink" title="2.2 envid2env(u_int envid, struct Env **penv, int checkperm)"></a>2.2 <code>envid2env(u_int envid, struct Env **penv, int checkperm)</code></h4><p>​		给定进程id <code>envid</code>，该函数的作用是：<strong>在<code>checkperm</code>父子条件下，查找<code>envid</code>的进程对应的进程控制块，若<code>envid</code>为0则返回当前进程的进程控制块</strong>。</p>
<p>​		若<code>envid</code>是0则将当前进程存储在<code>penv</code>中并返回0。否则查找该进程：如果未找到，或者找到了，但checkperm，且不是当前进程或者当前进程的子进程，则返回<code>-E_BAD_ENV</code>；否则将目的进程存储在<code>penv</code>中并返回0。</p>
<h4 id="2-3-sys-mem-alloc-u-int-envid-y-int-va-u-int-perm"><a href="#2-3-sys-mem-alloc-u-int-envid-y-int-va-u-int-perm" class="headerlink" title="2.3 sys_mem_alloc(u_int envid, y_int va, u_int perm)"></a>2.3 <code>sys_mem_alloc(u_int envid, y_int va, u_int perm)</code></h4><p>​		该函数的作用是：**给id为<code>envid</code>的进程的<code>va</code>所处的虚拟页，分配一个物理页，且置权限位为<code>perm</code>**。</p>
<h4 id="2-4-sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm"><a href="#2-4-sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm" class="headerlink" title="2.4 sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)"></a>2.4 <code>sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code></h4><p>​		该函数的作用是：**将目标进程<code>dstid</code>地址空间中<code>dstva</code>所在虚拟页，映射到源进程<code>srcid</code>地址空间中<code>srcva</code>所在虚拟页映射的物理页，且置权限位为<code>perm</code>**。</p>
<h4 id="2-5-sys-mem-unmap-u-int-envid-u-int-va"><a href="#2-5-sys-mem-unmap-u-int-envid-u-int-va" class="headerlink" title="2.5 sys_mem_unmap(u_int envid, u_int va)"></a>2.5 <code>sys_mem_unmap(u_int envid, u_int va)</code></h4><p>​		该函数的作用是：<strong>将进程<code>envid</code>地址空间中<code>dstva</code>所在虚拟页，解除可能存在的任何物理页映射</strong>。</p>
<h3 id="3-进程间通信机制"><a href="#3-进程间通信机制" class="headerlink" title="3.进程间通信机制"></a>3.进程间通信机制</h3><p>​		使用系统调用，以进程控制块为中介来实现。思路如下：</p>
<ul>
<li>接收方：在进程控制块中存储好需求信息，随后阻塞自己并放弃CPU。醒来时就已经接收完成。</li>
<li>发送方：直接依据<code>envid</code>获取接收方进程控制块。根据其中的需求字段，直接填充其渴望的信息，并在必要时执行<code>sys_mem_map</code>的逻辑。最后解除接收方的阻塞。</li>
</ul>
<p>接收方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//curenv-&gt;env_ipc_recving表示此进程是否在认真地聆听并求救，不然发送方可不理睬她</span></span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//需要将接收方进程dstva所在的虚拟页，映射到发送方进程映射的，某物理页</span></span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞自己</span></span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在此设置系统调用的返回值：0</span></span><br><span class="line">	((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//放弃CPU</span></span><br><span class="line">	schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//srcva要么为0，要么是合法可操作区域的va</span></span><br><span class="line">	<span class="keyword">if</span>(srcva !=<span class="number">0</span> &amp;&amp; is_illegal_va(srcva))&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取接收方进程控制块</span></span><br><span class="line">    <span class="comment">//双方不必有亲子关系，所以这里checkperm为0</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//接收方实际上并没有在接受信息，那么停止发送并报错</span></span><br><span class="line">	<span class="keyword">if</span>(!e-&gt;env_ipc_recving)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//传val值</span></span><br><span class="line">	e-&gt;env_ipc_value = value;</span><br><span class="line">    <span class="comment">//传入发送方自己的id</span></span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">    <span class="comment">//接收方将要收到消息，那么停止其接受信息的状态</span></span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解除接收方进程的阻塞</span></span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果srcva不为0，那么相当于额外执行一次sys_mem_map(0, srcva, envid, dstva,  perm)</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">		p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-写时复制"><a href="#4-写时复制" class="headerlink" title="4.写时复制"></a>4.写时复制</h3><h4 id="4-1-基本理解"><a href="#4-1-基本理解" class="headerlink" title="4.1 基本理解"></a>4.1 基本理解</h4><p>​		写时复制是为fork服务的机制，其主要目的是降低当场复制的性能消耗，并节约物理页。</p>
<p>​		在fork执行完成后，子进程在逻辑上来讲拥有自己完全独立的地址空间，其中大部分的内容（<code>USTACKTOP</code>以下）则复制自父进程调用fork时的状态。容易发现，直接无脑复制这接近2GB的内容是不必要的，例如几乎不会被修改、几乎只用作读的代码段。因此我们需要写时复制机制。</p>
<p>​		写时复制的<strong>本质是修改页表项中的<code>perm</code>位，以在写入时引发<code>TLB MOD</code>异常，在异常处理函数中再分配新的物理页。从而将物理复制操作推迟到了写入的一刻</strong>，且在此之前保证了“读”的正常运作。</p>
<p>​		写时复制的<strong>目标页是可写非共享页</strong>，因此写时复制的<code>perm</code>项特征如下，这能够将写时复制和只读、共享页、可写页区分开来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(perm &amp; PTE_V) &amp;&amp; (perm &amp; PTE_COW) &amp;&amp; !(perm &amp; PTE_D) &amp;&amp; !(perm &amp; PTE_LIBRARY)</span><br></pre></td></tr></table></figure>

<p>​		写时复制采用了微内核的思想，真正的处理函数<code>cow_entry</code>是一个用户态函数。</p>
<p>​		</p>
<h3 id="4-2-代码分析"><a href="#4-2-代码分析" class="headerlink" title="4.2 代码分析"></a>4.2 代码分析</h3><p>​		当进程试图写一个写时复制的页面时，即会触发一号异常：<code>TLB MOD</code>。大致流程如下（为了节约时间就不画图了））：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">引发TLBMOD的语句</span><br><span class="line">    </span><br><span class="line">|||||||触发TLBMOD，进入内核态|||||||</span><br><span class="line">    </span><br><span class="line">异常分发程序</span><br><span class="line">    SAVE_ALL，此时内核异常栈的栈顶被放入了tf结构体，保存了现场</span><br><span class="line">    根据exception_handlers[<span class="number">1</span>]，跳转到了handle_mod函数</span><br><span class="line">    </span><br><span class="line">handle_mod</span><br><span class="line">    将a0置为sp，此时sp指向异常栈栈顶tf结构体</span><br><span class="line">    以a0为参数调用do_tlb_mod</span><br><span class="line">        do_tlb_mod</span><br><span class="line">            判断是否有TLB_MOD重入的现象，并以此安置好现场中的sp指针</span><br><span class="line">            对用户异常栈压栈：</span><br><span class="line">            |----------------------|</span><br><span class="line">            |        tf结构体       |</span><br><span class="line">            |----------------------|</span><br><span class="line">            | 指向上面那个结构体的指针 |</span><br><span class="line">    		|----------------------|</span><br><span class="line">        						&lt;-------tf-&gt;regs[<span class="number">29</span>]</span><br><span class="line">            设置tf-&gt;cp0_epc为我们约定好的处理函数地址curenv-&gt;env_user_tlb_mod_entry</span><br><span class="line">  	ret_from_exception</span><br><span class="line">    	RESTORE_SOME</span><br><span class="line">    	设置好sp寄存器</span><br><span class="line">    	rfe</span><br><span class="line">    	跳转回EPC寄存器的值（即异常处理函数）</span><br><span class="line">    </span><br><span class="line">|||||||返回用户态，cow_entry|||||||</span><br><span class="line">    </span><br><span class="line">cow_entry</span><br><span class="line">    分发新的物理页，完成异常处理，其中有若干次系统调用。</span><br><span class="line">    syscall_set_trapframe(<span class="number">0</span>, tf)</span><br><span class="line">    </span><br><span class="line">|||||||系统调用自陷，进入内核态|||||||</span><br><span class="line">    </span><br><span class="line">异常分发程序 类似上面 在此略过</span><br><span class="line">    </span><br><span class="line">do_syscall</span><br><span class="line">	sys_set_trapframe</span><br><span class="line">    	手工将异常栈顶设置为传入的tf</span><br><span class="line">    	返回值设置为tf-&gt;regs[<span class="number">2</span>]</span><br><span class="line">ret_from_exception 类似上面 在此略过</span><br><span class="line">    </span><br><span class="line">|||||||返回用户态，重新执行前面引发TLB MOD的语句|||||||</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4-2-1-设置写时复制duppage-u-int-envid-u-int-vpn"><a href="#4-2-1-设置写时复制duppage-u-int-envid-u-int-vpn" class="headerlink" title="4.2.1 设置写时复制duppage(u_int envid, u_int vpn)"></a>4.2.1 设置写时复制<code>duppage(u_int envid, u_int vpn)</code></h4><p>​		写时复制是为<code>fork</code>服务的，在子进程创建完成后需要立刻进行写时复制。</p>
<h5 id="4-2-1-1-代码分析"><a href="#4-2-1-1-代码分析" class="headerlink" title="4.2.1.1 代码分析"></a>4.2.1.1 代码分析</h5><p>​		该函数的作用是，以<code>envid</code>为子进程的进程id号，对于第<code>vpn</code>个虚拟页进行写时复制的设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//...omit</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i*BY2PG &lt; USTACKTOP; i++)&#123;</span><br><span class="line">		duppage(child, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...omit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int addr;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="comment">//要操作的虚拟页的起始地址</span></span><br><span class="line">    <span class="comment">//复习关系式：虚拟地址 = 虚拟页号*BY2PG </span></span><br><span class="line">	addr = vpn * BY2PG;</span><br><span class="line">    <span class="comment">//利用用户态可获取页表的特性，查询该虚拟页的权限位</span></span><br><span class="line">    <span class="comment">//利用vpt</span></span><br><span class="line">	perm = vpt[vpn] &amp; (u_int)<span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在实际评测中，用户空间的大部分页面其实是空白的，对于没有内容的页面当然不需要写时复制。</span></span><br><span class="line">    <span class="comment">//如此一来便不会进入下面的else内，不会进行系统调用，从而减少了不必要的开销。</span></span><br><span class="line">	<span class="keyword">if</span>(!(perm &amp; PTE_V))&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//判断当前页面是否是可写非共享页面。如果是，那么进行写时复制</span></span><br><span class="line">	<span class="keyword">if</span>((perm &amp; PTE_D) &amp;&amp; !(perm &amp; PTE_LIBRARY) &amp;&amp; !(perm &amp; PTE_COW))&#123;</span><br><span class="line">        <span class="comment">//子进程写时复制的设置：映射至相同物理页并置perm</span></span><br><span class="line">		r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span>*)addr, envid, (<span class="type">void</span>*)addr, PTE_COW);</span><br><span class="line">        <span class="comment">//父进程写时复制的设置：仅置perm</span></span><br><span class="line">		r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span>*)addr, <span class="number">0</span>, (<span class="type">void</span>*)addr, PTE_COW);	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//对于共享页面、写时复制页面，仅需原样继承他们的perm</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span>*)addr, envid, (<span class="type">void</span>*)addr, perm);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		需要注意，<strong>不能先给父进程设置写时复制</strong>。否则因为用户栈本身也在写时复制的范围内，父进程会在写时复制完成后立即触发一次<code>TLB MOD</code>，在<code>cow_entry</code>中被映射一个新物理页并<strong>解除写时复制状态</strong>。此后<strong>父进程在该页的写，也会悄悄地同步给子进程</strong>，造成不可预料的后果。</p>
<h5 id="4-2-1-2-（复习）几个重要的宏："><a href="#4-2-1-2-（复习）几个重要的宏：" class="headerlink" title="4.2.1.2 （复习）几个重要的宏："></a>4.2.1.2 （复习）几个重要的宏：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/include/lib.h</span></span><br><span class="line"><span class="comment">//页表区指针:virtual page table</span></span><br><span class="line"><span class="comment">//访问va对应的页表项：vpt[va / BY2PG]，即vpt[VPN(va)]，vpt[va&gt;&gt;PGSHIFT]。VPN：virtual page number</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="comment">//页目录指针:virtual page dictionary</span></span><br><span class="line"><span class="comment">//访问va对应的页目录项：vpd[va / PDMAP]，即vpt[va&gt;&gt;PDSHIFT]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br><span class="line"><span class="comment">//进程控制块数组指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> envs ((volatile struct Env *)UENVS)</span></span><br><span class="line"><span class="comment">//物理页控制块数组指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pages ((volatile struct Page *)UPAGES)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user/lib/libo.c</span></span><br><span class="line"><span class="comment">//当前进程的控制块指针 注意该指针指向只读区域</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">//在进程伊始被初始化，这也是后面需要手动设置子进程env的原因</span></span><br><span class="line">	env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line"></span><br><span class="line">	main(argc, argv);</span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/mmu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096				<span class="comment">//一个页面的字节数, 2^&#123;12&#125;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDMAP (4 * 1024 * 1024)	<span class="comment">//一个页目录项管理的字节数，2^&#123;22&#125;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12				<span class="comment">//va &gt;&gt; PGSHIFT = 虚拟页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22				<span class="comment">//va &gt;&gt; PDSHIFT = 页目录项编号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF)					</span></span><br><span class="line">								<span class="comment">//取出va中的页目录项偏移。查页目录时用。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03FF)</span></span><br><span class="line">								<span class="comment">//取出va中在指定页表中的偏移。查页表时用。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br><span class="line">								<span class="comment">//取出页表项中的物理页号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) (((u_long)(va)) &gt;&gt; 12)</span></span><br><span class="line">								<span class="comment">//即 va &gt;&gt; PGSHIFT</span></span><br></pre></td></tr></table></figure>



<h5 id="4-2-1-3-复习sys-mem-map"><a href="#4-2-1-3-复习sys-mem-map" class="headerlink" title="4.2.1.3 复习sys_mem_map"></a>4.2.1.3 复习<code>sys_mem_map</code></h5><p>​		在此复习<code>sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code>的一些要点：</p>
<ul>
<li><p>作用是<strong>将<code>srcid</code>进程的<code>srcva</code>虚拟页所映射的物理页，同样映射给<code>dstid</code>进程的<code>dstva</code>虚拟页</strong>，并置以权限<code>perm&amp;PTE_V</code>。换句话说<strong>两个不同进程的两个虚拟地址，此时映射到同一物理页</strong>。</p>
</li>
<li><p>实现基于<code>pgge_insert</code>，而<code>page_insert</code>又基于<code>pgdir_walk</code>。</p>
</li>
<li><p>若<code>dstva</code>已映射至物理页，则先解除之；如果<code>dstva</code>尚未映射至物理页，则直接映射之。</p>
</li>
<li><p><code>srcid</code>为0时代表当前进程（即用户态下的<code>env-&gt;env_id</code>）。</p>
</li>
<li><p>可以用于映射并置<code>perm</code>，当然也可以仅用于置<code>perm</code>。</p>
</li>
</ul>
<h4 id="4-2-2-写时复制内核处理函数do-tlb-mod-struct-Trapframe-tf"><a href="#4-2-2-写时复制内核处理函数do-tlb-mod-struct-Trapframe-tf" class="headerlink" title="4.2.2 写时复制内核处理函数do_tlb_mod(struct Trapframe *tf)"></a>4.2.2 写时复制内核处理函数<code>do_tlb_mod(struct Trapframe *tf)</code></h4><p>​		我们真正的异常处理逻辑是在用户态完成的，因此<code>do_tlb_mod</code>需要为重返用户态做好一切准备。多亏了<code>SAVE_ALL</code>以及<code>ret_from_exception</code>等，内核可以完全得知用户进程当前的状态，并完全控制它未来的去向。</p>
<ul>
<li>将<code>sp</code>指针设置在用户异常栈的合适位置</li>
<li>在用户异常栈中放入数据。<strong>由于用户异常栈不在写时复制范围内，因此不必担心死循环</strong>。</li>
<li>设置<code>epc</code>寄存器的值为我们约定的处理函数</li>
<li>最后交由<code>ret_from_exception</code>处理，返回用户态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line">	<span class="comment">//如果非异常重入，我们就需要把sp设置到异常栈顶</span></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将现场tf压栈</span></span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">	*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        <span class="comment">//将指向现场的指针作为cow_entry的参数压栈</span></span><br><span class="line">		tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">		<span class="comment">// 设置返回地址为函数cow_entry的地址，如此一来便能够从cow_entry处开始执行用户态进程</span></span><br><span class="line">		tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们对用户异常栈所做的修改如下：</span></span><br><span class="line"><span class="comment">//|----------------------|&lt;------原先的栈底</span></span><br><span class="line"><span class="comment">//|        tf结构体       |</span></span><br><span class="line"><span class="comment">//|----------------------|</span></span><br><span class="line"><span class="comment">//| 指向上面那个结构体的指针 |（目前还没压入，需要等到a0被设置为函数参数时才会被传入）</span></span><br><span class="line"><span class="comment">//|----------------------|</span></span><br><span class="line">        				<span class="comment">//&lt;-------现在的tf-&gt;regs[29]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-写时复制实际处理函数cow-entry-struct-Trapframe-tf"><a href="#4-2-3-写时复制实际处理函数cow-entry-struct-Trapframe-tf" class="headerlink" title="4.2.3 写时复制实际处理函数cow_entry(struct Trapframe *tf)"></a>4.2.3 写时复制实际处理函数<code>cow_entry(struct Trapframe *tf)</code></h4><p>​		芝士<code>TLB MOD</code>的处理函数，位于用户态。<strong>其工作是完成被推迟的物理页复制和分配，即把产生<code>TLB MOD</code>的虚拟页面映射到一个新的、内容相同的物理页上</strong>。</p>
<p>​		这是一个不返回的函数，最后通过<code>syscall_set_trapframe</code>来返回产生<code>TLB MOD</code>的语句。</p>
<p>​		这个函数支持异常重入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf)&#123;</span><br><span class="line">    <span class="comment">//取出产生异常的虚拟地址</span></span><br><span class="line">    u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">	u_int perm;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//透过暴露到用户态的页表取出perm，以确定当前页的的确确是写时复制的</span></span><br><span class="line">	perm = vpt[VPN(va)] &amp; (u_int)<span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(perm &amp; PTE_COW))&#123;</span><br><span class="line">		user_panic(<span class="string">&quot;perm doesn&#x27;t have PTE_COW&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将新的perm设置为可写</span></span><br><span class="line">	perm = (perm | PTE_D) &amp; (~PTE_COW);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//给周转页UCOW分配一个物理页</span></span><br><span class="line">	syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span>*)UCOW, perm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向周转页内复制异常页的内容</span></span><br><span class="line">	va = ROUNDDOWN(va, BY2PG);</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span>*)UCOW, (<span class="type">void</span>*)va, BY2PG);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//让va映射到周转页的物理页，且置perm</span></span><br><span class="line">	syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span>*)UCOW, <span class="number">0</span>, (<span class="type">void</span>*)va, perm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移除周转页，如此一来，va就独占了周转页的物理页</span></span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span>*)UCOW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回引发异常的语句，结束本次异常处理</span></span><br><span class="line">	<span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">	user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		流程图解如下：</p>
<p><img src="C:\Users\24712\AppData\Roaming\Typora\typora-user-images\image-20230507234255184.png" alt="image-20230507234255184"></p>
<h3 id="5-fork"><a href="#5-fork" class="headerlink" title="5.fork"></a>5.fork</h3><p>​		<code>fork()</code>是一个用户态函数。当一个进程调用<code>fork()</code>后，将诞生一个新进程。</p>
<p>​		这个新进程开始运行时的大部分上下文状态与原进程相同，包括程序和 fork 运行时的现场（包括通用寄存器和程序计数器 PC 等）。原进程的<code>fork()</code>返回子进程的<code>env_id</code>，子进程的<code>fork()</code>返回0，用以区别子进程和父进程。</p>
<p>​		我们可以用抽象且顽皮的话来总结fork及写时复制的流程：子进程的创建过程就像是把一个培育好的缸中之脑，放入一具与本尊几乎一致的身体当中。因为它不是纯天然的，并没有实际经历父进程躺在手术台上之前的人生（例如在<code>libmain</code>里设置<code>env</code>），因此我们需要手工设置好脑中的种种参数，并在手术后将它放在舒服的队列里，等待它被<code>schedule()</code>唤醒。因为我们很穷很穷，所以子进程不得不与父进程共用一套课本，如果两者之一非得哭着喊着往上面做笔记并且玉玉触发异常，我们才用特权给它克隆出来一个新课本。</p>
<h4 id="5-1syscall-exofork"><a href="#5-1syscall-exofork" class="headerlink" title="5.1syscall_exofork()"></a>5.1<code>syscall_exofork()</code></h4><p>​		该系统调用的作用是<strong>初步创建一个子进程，设置好它的进程控制块</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配进程控制块env_alloc</span></span><br><span class="line">	try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置子进程的现场与父进程一致</span></span><br><span class="line">	e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值0以区分父子进程</span></span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子进程目前还不能运行，因为我们还没有设置它的虚拟地址空间，env以及TLB_MOD处理函数</span></span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    <span class="comment">//进程优先级</span></span><br><span class="line">	e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		由于继承了父进程的现场，因此<strong>子进程苏醒后会从<code>syscall_exofork()</code>处，以0返回值继续执行</strong>。就好像他自己并不是一个克隆人，而是刚刚执行了<code>syscall_exofork()</code>且返回了0一样。</p>
<h4 id="5-2-syscall-set-tlb-mod-entry-u-int-envid-u-int-func"><a href="#5-2-syscall-set-tlb-mod-entry-u-int-envid-u-int-func" class="headerlink" title="5.2 syscall_set_tlb_mod_entry(u_int envid, u_int func)"></a>5.2 <code>syscall_set_tlb_mod_entry(u_int envid, u_int func)</code></h4><p>​		该系统调用的作用是**将进程控制块中记录的<code>TLB_MOD</code>处理函数字段设置为函数指针<code>func</code>**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在内核态下，拥有env_id时即可使用envid2env()来获取进程控制块</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//直接设置</span></span><br><span class="line">	env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-syscall-set-env-status-u-int-envid-u-int-status"><a href="#5-3-syscall-set-env-status-u-int-envid-u-int-status" class="headerlink" title="5.3 syscall_set_env_status(u_int envid, u_int status)"></a>5.3 <code>syscall_set_env_status(u_int envid, u_int status)</code></h4><p>​		该系统调用的作用是**设置指定<code>envid</code>进程的运行状态<code>status</code>**。用于父进程在完成子进程的设置后，做唤醒的最后一步准备工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//无权设置为ENV_FREE状态</span></span><br><span class="line">	<span class="keyword">if</span>(status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//envid2env(envid, &amp;env, 1)</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//只允许就绪态和非就绪态的切换</span></span><br><span class="line">    <span class="comment">//切换时维护调度队列</span></span><br><span class="line">    <span class="comment">//转换为就绪态，则加入队列TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link)</span></span><br><span class="line">	<span class="keyword">if</span>(env-&gt;env_status == ENV_NOT_RUNNABLE &amp;&amp; status == ENV_RUNNABLE)&#123;</span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//转换为非就绪态，则移出队列TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link)</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(env-&gt;env_status == ENV_RUNNABLE &amp;&amp; status == ENV_NOT_RUNNABLE)&#123;</span><br><span class="line">		TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置进程控制块里的status</span></span><br><span class="line">	env-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-fork"><a href="#5-4-fork" class="headerlink" title="5.4 fork()"></a>5.4 <code>fork()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int child;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//确保父进程设置好了TLB_MOD的处理函数</span></span><br><span class="line">    <span class="keyword">if</span>(env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生子进程。子进程苏醒后也是从child = 0开始</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//对于子进程，还需要维护env</span></span><br><span class="line">        <span class="comment">//ENVX(envid)宏已经在lab3总结过，其利用envid的后10位取出envid对应的进程控制块</span></span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父进程在子进程产生后，可调度前，设置好子进程的虚拟地址空间，并完成双方的写时复制</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i * BY2PG &lt; USTACKTOP; i++)&#123;</span><br><span class="line">        duppage(child, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置好子进程的TLB_MOD处理函数</span></span><br><span class="line">    try(syscall_set_tlb_mod_entry(child, cow_entry));</span><br><span class="line">    <span class="comment">//一切就绪，设置子进程为就绪状态</span></span><br><span class="line">    try(syscall_set_env_status(child, ENV_RUNNABLE));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h2 id="三、实验体会"><a href="#三、实验体会" class="headerlink" title="三、实验体会"></a>三、实验体会</h2><p>​		完成lab4后，我体会到了一步一步逐渐想明白进程在用户态和内核态间的旅行穿梭过程，搞清楚通用寄存器和cp0中部分寄存器保存、再设置、恢复的位置和作用，体会三种栈的作用和设置过程，一步步debug，最终完成实验的快感。</p>
<p>​		相反，lab5其实称得上是有一点迷惑。<strong>lab5引入了一套把用户态的文件管理进程作为”伺服器“，以进程间通信的形式，与事先提供的用户进程接口对接，从而实现文件管理的文件管理系统。对于这样一个代码量不算小，难度称不上低的全新体系，代码中却鲜有注释（很多函数甚至没有注释），指导书也语焉不详，且题目在几乎无法理解部分代码的情况下仍然可以根据hint快速完成</strong>。我不太清楚这是不是助教有意为之：几乎不给出整个流程全貌（即之前每章最后都有的流程图），不给出很多关键具体细节的解释，从而考验大火自读代码，自己勾勒系统框架的能力，但lab5课下带给我的体验确实不算是好。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">H1kari</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/20/OSlab-report-4/">http://example.com/2023/08/20/OSlab-report-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">H1kari's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/default_cover_3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/20/OSlab-report-1/" title="BUAA2023春OS课程LAB1实验报告"><img class="cover" src="/img/default_cover_4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA2023春OS课程LAB1实验报告</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">H1kari</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">亻尔女子, this is my blog.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">Lab4实验报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thinking"><span class="toc-number">1.1.</span> <span class="toc-text">Thinking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Thinking 4.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">（1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">（2）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">（3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">（4）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-2"><span class="toc-number">1.1.2.</span> <span class="toc-text">Thinking 4.2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-3"><span class="toc-number">1.1.3.</span> <span class="toc-text">Thinking 4.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-4"><span class="toc-number">1.1.4.</span> <span class="toc-text">Thinking 4.4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9C"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">选择C</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-5"><span class="toc-number">1.1.5.</span> <span class="toc-text">Thinking 4.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-6"><span class="toc-number">1.1.6.</span> <span class="toc-text">Thinking 4.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-7"><span class="toc-number">1.1.7.</span> <span class="toc-text">Thinking 4.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-8"><span class="toc-number">1.1.8.</span> <span class="toc-text">Thinking 4.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thinking-4-9"><span class="toc-number">1.1.9.</span> <span class="toc-text">Thinking 4.9</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9A%BE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.</span> <span class="toc-text">二、难点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.系统调用的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-syscall-%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1 syscall_*系列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">1.1.1 函数作用总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%A5%E7%B3%BB%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%BB%E8%A6%81%E6%98%AF%EF%BC%9A%E5%9C%A8%E9%99%B7%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%E5%89%8D%EF%BC%8C%E5%AE%89%E7%BD%AE%E5%A5%BD%E4%BC%A0%E9%80%92%E7%BB%99%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">该系列函数的作用主要是：在陷入内核态前，安置好传递给内核态的参数。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E6%A0%88%E5%B8%A7"><span class="toc-number">1.2.1.1.3.</span> <span class="toc-text">1.1.2 栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E4%BC%A0%E5%8F%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.1.4.</span> <span class="toc-text">1.1.3 传参原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-msyscall%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 msyscall函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BC%82%E5%B8%B8%E5%88%86%E5%8F%91%E5%85%A5%E5%8F%A3"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">1.3 异常分发入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-handle-syscall%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">1.4 handle_syscall函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-do-syscall%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">1.5 do_syscall函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-ret-from-exception%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">1.6 ret_from_exception函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.系统调用的内核处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-is-illegal-va-u-long-va"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.1 is_illegal_va(u_long va)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-envid2env-u-int-envid-struct-Env-penv-int-checkperm"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2 envid2env(u_int envid, struct Env **penv, int checkperm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-sys-mem-alloc-u-int-envid-y-int-va-u-int-perm"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.3 sys_mem_alloc(u_int envid, y_int va, u_int perm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.4 sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-sys-mem-unmap-u-int-envid-u-int-va"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.5 sys_mem_unmap(u_int envid, u_int va)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.进程间通信机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.写时复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">4.1 基本理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">4.2 代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.5.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E8%AE%BE%E7%BD%AE%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6duppage-u-int-envid-u-int-vpn"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">4.2.1 设置写时复制duppage(u_int envid, u_int vpn)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-1-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">4.2.1.1 代码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-2-%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%AE%8F%EF%BC%9A"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">4.2.1.2 （复习）几个重要的宏：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-3-%E5%A4%8D%E4%B9%A0sys-mem-map"><span class="toc-number">1.2.5.2.3.</span> <span class="toc-text">4.2.1.3 复习sys_mem_map</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0do-tlb-mod-struct-Trapframe-tf"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">4.2.2 写时复制内核处理函数do_tlb_mod(struct Trapframe *tf)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%AE%9E%E9%99%85%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0cow-entry-struct-Trapframe-tf"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">4.2.3 写时复制实际处理函数cow_entry(struct Trapframe *tf)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-fork"><span class="toc-number">1.2.6.</span> <span class="toc-text">5.fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1syscall-exofork"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">5.1syscall_exofork()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-syscall-set-tlb-mod-entry-u-int-envid-u-int-func"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">5.2 syscall_set_tlb_mod_entry(u_int envid, u_int func)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-syscall-set-env-status-u-int-envid-u-int-status"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">5.3 syscall_set_env_status(u_int envid, u_int status)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-fork"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">5.4 fork()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AE%9E%E9%AA%8C%E4%BD%93%E4%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">三、实验体会</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/pic-1/" title="网络趣味图片1"><img src="/img/default_cover_4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络趣味图片1"/></a><div class="content"><a class="title" href="/2023/08/20/pic-1/" title="网络趣味图片1">网络趣味图片1</a><time datetime="2023-08-19T16:47:45.984Z" title="发表于 2023-08-20 00:47:45">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/OSlab-report-3/" title="BUAA2023春OS课程LAB3实验报告"><img src="/img/default_cover_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023春OS课程LAB3实验报告"/></a><div class="content"><a class="title" href="/2023/08/20/OSlab-report-3/" title="BUAA2023春OS课程LAB3实验报告">BUAA2023春OS课程LAB3实验报告</a><time datetime="2023-08-19T16:45:27.371Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/OSlab-report-2/" title="BUAA2023春OS课程LAB2实验报告"><img src="/img/default_cover_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023春OS课程LAB2实验报告"/></a><div class="content"><a class="title" href="/2023/08/20/OSlab-report-2/" title="BUAA2023春OS课程LAB2实验报告">BUAA2023春OS课程LAB2实验报告</a><time datetime="2023-08-19T16:45:27.367Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/OSlab-report-1/" title="BUAA2023春OS课程LAB1实验报告"><img src="/img/default_cover_4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023春OS课程LAB1实验报告"/></a><div class="content"><a class="title" href="/2023/08/20/OSlab-report-1/" title="BUAA2023春OS课程LAB1实验报告">BUAA2023春OS课程LAB1实验报告</a><time datetime="2023-08-19T16:45:27.364Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/OSlab-report-4/" title="BUAA2023春OS课程LAB4实验报告"><img src="/img/default_cover_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023春OS课程LAB4实验报告"/></a><div class="content"><a class="title" href="/2023/08/20/OSlab-report-4/" title="BUAA2023春OS课程LAB4实验报告">BUAA2023春OS课程LAB4实验报告</a><time datetime="2023-08-19T16:45:27.347Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By H1kari</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>