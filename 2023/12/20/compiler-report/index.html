<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA2023秋编译原理 实验文档 | H1kari's Blog</title><meta name="author" content="H1kari"><meta name="copyright" content="H1kari"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编译文档 1. 参考编译器介绍参考了2020级编译原理课程的编译器实现Noietch&#x2F;SysYCompiler (github.com)。 1.1 总体结构编译过程分为如下阶段： 词法分析，语法分析，错误处理，语法分析与llvm生成，llvm优化，mips生成及优化。  前端  词法分析。构建了贪心简化的DFA，输入源程序，输出token序列。  语法分析。透过递归下降子程序进行语法分析">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA2023秋编译原理 实验文档">
<meta property="og:url" content="http://example.com/2023/12/20/compiler-report/index.html">
<meta property="og:site_name" content="H1kari&#39;s Blog">
<meta property="og:description" content="编译文档 1. 参考编译器介绍参考了2020级编译原理课程的编译器实现Noietch&#x2F;SysYCompiler (github.com)。 1.1 总体结构编译过程分为如下阶段： 词法分析，语法分析，错误处理，语法分析与llvm生成，llvm优化，mips生成及优化。  前端  词法分析。构建了贪心简化的DFA，输入源程序，输出token序列。  语法分析。透过递归下降子程序进行语法分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg">
<meta property="article:published_time" content="2023-12-20T15:59:23.419Z">
<meta property="article:modified_time" content="2024-02-28T15:13:36.059Z">
<meta property="article:author" content="H1kari">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg"><link rel="shortcut icon" href="/img/hfavicon.png"><link rel="canonical" href="http://example.com/2023/12/20/compiler-report/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA2023秋编译原理 实验文档',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-28 23:13:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="H1kari's Blog"><span class="site-name">H1kari's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA2023秋编译原理 实验文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-20T15:59:23.419Z" title="发表于 2023-12-20 23:59:23">2023-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-28T15:13:36.059Z" title="更新于 2024-02-28 23:13:36">2024-02-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA2023秋编译原理 实验文档"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="编译文档"><a href="#编译文档" class="headerlink" title="编译文档"></a>编译文档</h1><p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/IMG_20230711_023016.jpg" alt="IMG_20230711_023016"></p>
<h2 id="1-参考编译器介绍"><a href="#1-参考编译器介绍" class="headerlink" title="1. 参考编译器介绍"></a>1. 参考编译器介绍</h2><p>参考了2020级编译原理课程的编译器实现<a target="_blank" rel="noopener" href="https://github.com/Noietch/SysYCompiler">Noietch&#x2F;SysYCompiler (github.com)</a>。</p>
<h4 id="1-1-总体结构"><a href="#1-1-总体结构" class="headerlink" title="1.1 总体结构"></a>1.1 总体结构</h4><p>编译过程分为如下阶段：</p>
<p>词法分析，语法分析，错误处理，语法分析与<code>llvm</code>生成，<code>llvm</code>优化，<code>mips</code>生成及优化。</p>
<ul>
<li><p>前端</p>
<ul>
<li><p>词法分析。构建了贪心简化的DFA，输入源程序，输出token序列。</p>
</li>
<li><p>语法分析。透过递归下降子程序进行语法分析。其中采用了扩充的BNF范式解决左递归问题，采用了预读FIRST集的方式来解决回溯问题。</p>
</li>
<li><p>错误处理。进行一次递归下降来构建符号表，诊查某些错误。</p>
</li>
<li><p>语法分析与<code>llvm</code>代码生成。遍历语法分析生成的AST，构建<code>llvm</code>中间代码。</p>
</li>
</ul>
</li>
<li><p>中端(<code>llvm</code>优化)</p>
<ul>
<li>死代码删除。</li>
</ul>
</li>
<li><p>后端(<code>mips</code>代码生成及优化)</p>
<ul>
<li>基于引用计数的寄存器分配</li>
</ul>
</li>
</ul>
<h4 id="1-2-文件组织与接口设计"><a href="#1-2-文件组织与接口设计" class="headerlink" title="1.2 文件组织与接口设计"></a>1.2 文件组织与接口设计</h4><h5 id="1-2-1-文件组织"><a href="#1-2-1-文件组织" class="headerlink" title="1.2.1 文件组织"></a>1.2.1 文件组织</h5><p>各个包及包内的部分关键类罗列如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">├── Front	// 前端</span><br><span class="line">|   ├── LexicalAnalyzer	// 词法分析</span><br><span class="line">|   |	└── CategoryCode.java			// token类型的、保留字、分界符的设定</span><br><span class="line">|   │   └── Scanner.java				// 词法分析的贪心DFA实现类</span><br><span class="line">|   |	└── Token.java					// token类</span><br><span class="line">|   ├── SyntaxAnalyzer	// 语法分析和错误处理</span><br><span class="line">|   |	├── Element			// node们</span><br><span class="line">|	|	|	└── &lt;文法非终结符&gt;.java		// node类</span><br><span class="line">|   |	├── SymbolTable		// 符号表</span><br><span class="line">|	|	|	└── Symbol.java				// 符号类</span><br><span class="line">|	|	|	└── SymbolTable.java		// 符号表类</span><br><span class="line">|   |	└── ErrorHandler.java			// 错误处理类</span><br><span class="line">|   |	└── SyntaxError.java			// 错误类</span><br><span class="line">|   |	└── TokenHandler.java			// 语法分析的递归下降实现类</span><br><span class="line">├── Middle				// 中间代码生成</span><br><span class="line">|   ├── IRElement			// values</span><br><span class="line">|   |	└── Type						// value的类型们</span><br><span class="line">|   │   └── Instructions				// Instruction value们</span><br><span class="line">|   |	└── Basic						// Module, Block等基本要素</span><br><span class="line">|   |	└── Use.java	</span><br><span class="line">|   |	└── User.java	</span><br><span class="line">|   |	└── Value.java	</span><br><span class="line">|   |	└── ValueTable.java	</span><br><span class="line">|   ├── VirtualRegister.java			// 虚拟寄存器分配</span><br><span class="line">│   ├── IRbuilder.java					// 中间代码的入口类及llvm生成的递归下降实现</span><br><span class="line">├── Backend				// Mips生成与优化 </span><br><span class="line">|   ├── Mem					// 寄存器类</span><br><span class="line">|   |	└── RealRegister.java			// 物理寄存器</span><br><span class="line">|   │   └── VirtualRegister.java		// 虚拟寄存器</span><br><span class="line">|   ├── OptimizeCodeGen		// Mips生成</span><br><span class="line">|   |	└── OptimizeCodeGen.java		// Mips生成的入口及实现方法</span><br><span class="line">|   │   └── RefCounter.java				// 引用计数类</span><br><span class="line">|   │   └── OpMemManager.java			// 临时寄存器</span><br><span class="line">|   ├── MipsInstruction.java			// 指令类</span><br><span class="line">├── Utils		// 存放工具类 </span><br><span class="line">├── CompilerConfig.java				// 编译器参数配置</span><br><span class="line">└── Compiler.java					// 编译器入口</span><br></pre></td></tr></table></figure>

<h2 id="2-编译器总体设计"><a href="#2-编译器总体设计" class="headerlink" title="2. 编译器总体设计"></a>2. 编译器总体设计</h2><h4 id="2-1-总体结构"><a href="#2-1-总体结构" class="headerlink" title="2.1 总体结构"></a>2.1 总体结构</h4><p>编译过程分为如下阶段：</p>
<p>词法分析，语法分析，错误处理，语法分析与<code>llvm</code>生成，<code>llvm</code>优化，<code>mips</code>生成及优化。</p>
<ul>
<li><p>前端</p>
<ul>
<li><p>词法分析。构建了贪心简化的DFA，输入源程序，输出token序列。</p>
</li>
<li><p>语法分析。透过递归下降子程序，实际上进行的是最左推导。其中采用了扩充的BNF范式解决左递归问题，采用了预读FIRST集的方式来解决回溯问题。</p>
</li>
<li><p>错误处理。在词法分析、语法分析中已进行了部分错误处理，这里专门再进行一次递归下降来诊查某些错误。</p>
</li>
<li><p>语法分析与<code>llvm</code>代码生成。遍历语法分析生成的AST，构建<code>llvm</code>中间代码。构建过程中采用了“走后门”的SSA。</p>
</li>
</ul>
</li>
<li><p>中端(<code>llvm</code>优化)</p>
<p>中端实现了Mem2reg，重构并生成了带有<code>phi</code>函数的中间代码。</p>
<ul>
<li>构建控制流图(CFG)，求解支配者与支配边界。</li>
<li>重构SSA，<code>phi</code>指令的插入与变量重命名。</li>
</ul>
</li>
<li><p>后端(<code>mips</code>代码生成及优化)</p>
<ul>
<li>非<code>phi</code>指令中间代码的翻译，<code>phi</code>指令的翻译。至此为止分配的都是虚拟寄存器。</li>
<li>图着色寄存器分配。</li>
<li>少量窥孔优化。</li>
</ul>
</li>
</ul>
<p>由于在我们的编译实验当中，作业是迭代进行的，因此为了降低开发难度，每个编译阶段都相对独立，且都至少对源程序或其中间形式遍历了一轮，且每一遍中都根据具体需求独立建立一遍符号表。</p>
<h4 id="2-2-文件组织与接口设计"><a href="#2-2-文件组织与接口设计" class="headerlink" title="2.2 文件组织与接口设计"></a>2.2 文件组织与接口设计</h4><h5 id="2-2-1-文件组织"><a href="#2-2-1-文件组织" class="headerlink" title="2.2.1 文件组织"></a>2.2.1 文件组织</h5><p>各个包及包内的部分关键类罗列如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">├── config		// 参数</span><br><span class="line">│   └── Config.java					// 参数设置</span><br><span class="line">├── frontend	// 前端入口</span><br><span class="line">│   └── Lexer.java					// 词法分析入口及分析方法</span><br><span class="line">|	└── Parser.java					// 语法分析入口及分析方法</span><br><span class="line">|	└── Checker.java				// 错误处理入口</span><br><span class="line">├── token		// token包</span><br><span class="line">│   └── Token.java					// TOken类</span><br><span class="line">|	└── TokenType.java				// Token类型及保留字、分界符等规定信息</span><br><span class="line">├── node		// 用于递归下降的node包</span><br><span class="line">│   └── &lt;文法非终结符&gt;.java			// node类，放置有语法分析、错误处理、ir的递归下降方法	</span><br><span class="line">├── error		// 错误处理</span><br><span class="line">|	└── Error.java					// 错误类</span><br><span class="line">│   └── ErrorHandler.java			// 错误的记录与输出</span><br><span class="line">|	└── ErrorCheckTool.java			// 错误的工厂类</span><br><span class="line">├── symbol		// 错误处理，符号及栈式符号表</span><br><span class="line">│   └── Symbol.java					// 符号类</span><br><span class="line">|	└── SymbolTable.java			// 符号表类</span><br><span class="line">|	└── SymbolTableStack.java		// 栈式符号表类</span><br><span class="line">├── ir			// 中间代码生成与优化</span><br><span class="line">|   ├── analyze				// 中间代码优化</span><br><span class="line">|   ├── types				// value的类型</span><br><span class="line">|   ├── values				// values</span><br><span class="line">|   |	└── constants				// Constant value们</span><br><span class="line">|   │   └── instructions			// Instruction value们</span><br><span class="line">|   |	└── BasicBlock.java			</span><br><span class="line">|   |	└── Function.java			</span><br><span class="line">|   |	└── GlobalVariable.java	</span><br><span class="line">|   |	└── Module.java	</span><br><span class="line">|   |	└── Value.java	</span><br><span class="line">|   |	└── User.java		</span><br><span class="line">|   ├── Irc.java					// 在中间代码生成中保存上下文信息</span><br><span class="line">│   ├── Irbuilder.java				// 中间代码的入口类及工厂类</span><br><span class="line">├── backend		// Mips生成与优化 </span><br><span class="line">|   ├── instructions		// Instruction们</span><br><span class="line">|   ├── operands			// 操作数们，包括立即数，虚拟、物理寄存器，标签</span><br><span class="line">|   ├── opt					// 目标代码优化</span><br><span class="line">|   |	└── BlockliveVarInfo.java	// 活跃变量分析</span><br><span class="line">|   │   └── RegBuilder.java			// 图着色寄存器分配</span><br><span class="line">|   |	└── Peephole.java			// 窥孔优化</span><br><span class="line">|   ├── Mc.java						// 在目标代码生成中保存上下文信息</span><br><span class="line">|   └── MipsBuilder.java			// 目标代码的入口及指令的工厂类</span><br><span class="line">├── utils		// 存放工具类 </span><br><span class="line">└── Compiler.java			// 编译器入口</span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-编译器入口"><a href="#2-2-2-编译器入口" class="headerlink" title="2.2.2 编译器入口"></a>2.2.2 编译器入口</h5><p>编译器的入口为<code>src/Compiler.java</code>。</p>
<p>调用<code>Compiler</code>类的<code>doCompileing()</code>方法即可对指定文件进行编译，并生成相应的<code>llvm</code>和<code>mips</code>代码。</p>
<h5 id="2-2-3-参数设定"><a href="#2-2-3-参数设定" class="headerlink" title="2.2.3 参数设定"></a>2.2.3 参数设定</h5><p>在<code>config.Config.java</code>进行编译器的设置，包括IO路径设置、是否生成<code>mips</code>代码、是否开启优化、是否开启控制台debug输出等。例如部分优化配置开关：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	// 是否生成Mips 为false则只生成llvm,不进入后端</span><br><span class="line">    public static boolean genMips = true;</span><br><span class="line">// ============== 优化配置开关 ================</span><br><span class="line">    // 是否开启Mem2Reg优化（否则就会生成慢吞吞的半吊子SSA，疯狂偷吃存取指令）</span><br><span class="line">    public static boolean openMem2RegOpt = true;</span><br><span class="line">    // 是否开启寄存器分配（debug用，不开启则会输出虚拟机寄存器）</span><br><span class="line">    public static boolean openRegAllocOpt = true;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-各编译阶段入口"><a href="#2-2-4-各编译阶段入口" class="headerlink" title="2.2.4 各编译阶段入口"></a>2.2.4 各编译阶段入口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── frontend</span><br><span class="line">│   └── Lexer.java		// 词法分析</span><br><span class="line">|	└── Parser.java		// 语法分析</span><br><span class="line">|	└── Checker.java	// 错误处理</span><br><span class="line">├── ir</span><br><span class="line">│   ├── Irbuilder.java	// 中间代码生成与优化</span><br><span class="line">└── backend</span><br><span class="line">    └── MipsBuilder.java	// 目标代码生成与优化</span><br></pre></td></tr></table></figure>

<p>每一个编译阶段都有其入口类，入口类们在<code>src/Compiler.java</code>被串联在一起。</p>
<p>入口类均实现了<code>CompilePhase</code>接口。入口类需要在构造方法中传入上一个阶段的输出，再调用<code>process()</code>方法以进行分析，最后调用<code>outputResult()</code>方法以将结果输出至文件。</p>
<h2 id="3-词法分析"><a href="#3-词法分析" class="headerlink" title="3. 词法分析"></a>3. 词法分析</h2><h4 id="3-1-总体思路"><a href="#3-1-总体思路" class="headerlink" title="3.1 总体思路"></a>3.1 总体思路</h4><p>词法分析部分的主要任务是顺序遍历源程序代码，将其按照文法转化为token序列。</p>
<p>词法分析可以透过正则表达式或者<strong>贪心简化过的DFA</strong>实现，我采用了后者。</p>
<p>与词法分析相关的文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── frontend	// 前端入口</span><br><span class="line">│   └── Lexer.java					// 词法分析入口及分析方法</span><br><span class="line">├── token		// token包</span><br><span class="line">│   └── Token.java					// TOken类</span><br><span class="line">|	└── TokenType.java				// Token类型及保留字、分界符等规定信息</span><br></pre></td></tr></table></figure>

<h4 id="3-2-DFA的设计"><a href="#3-2-DFA的设计" class="headerlink" title="3.2 DFA的设计"></a>3.2 DFA的设计</h4><p>DFA的实现位于<code>fronted/Lexer.java</code></p>
<p>我们的单词大致分为四类，分别是保留字、 字符串常量、标识符、分界符。<strong>透过不同类别的FIRST集合，即可根据当前字符，确定下面将要处理的单词的大致种类</strong>。</p>
<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220103042494.png" alt="image-20231220103042494"></p>
<p>调用<code>next()</code>方法即可读取下一个token，大致框架如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 立即获取下一个token</span><br><span class="line">    public Token next () throws LexerException &#123;</span><br><span class="line">        // 跳过注释和空白符</span><br><span class="line">        jumpWhiteCharacter();</span><br><span class="line">        while(jumpNote() != 0)&#123;</span><br><span class="line">            jumpWhiteCharacter();</span><br><span class="line">        &#125;</span><br><span class="line">        // 按照首字符进行贪心匹配</span><br><span class="line">        char chr = text.charAt(pos);</span><br><span class="line">        // 1.数字开头 应为数字</span><br><span class="line">        if (Character.isDigit(chr)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.字母或下划线开头 应为保留字或者标识符</span><br><span class="line">        else if (Character.isLetter(chr) || chr == &#x27;_&#x27;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            TokenType type = TokenType.isReservedToken(str); // 先判断是否是保留字</span><br><span class="line">            // 是保留字</span><br><span class="line">            if(type!=null)&#123;</span><br><span class="line">                token = new Token(str, lineNum, type);</span><br><span class="line">            &#125;</span><br><span class="line">            // 是标识符</span><br><span class="line">            else&#123;</span><br><span class="line">                token = new Token(str, lineNum, TokenType.IDENFR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.双引号 格式化字符串</span><br><span class="line">        else if(chr == &#x27;&quot;&#x27;)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        // 4.单字符或双字符分隔符</span><br><span class="line">        else&#123;</span><br><span class="line">           ...</span><br><span class="line">            if(flagSingle)&#123;</span><br><span class="line">                tokenType = TokenType.getTokenType((str = text.substring(pos, pos+1)));</span><br><span class="line">                posMove = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            // 可能的双字符分隔符 要截取两位来生成token</span><br><span class="line">            if(pos &lt; maxPos &amp;&amp; flagDouble)&#123;</span><br><span class="line">                TokenType tmp = TokenType.getTokenType(text.substring(pos, pos+2));</span><br><span class="line">                // 确认生成成功后，再进行记录，以防覆盖单双皆可的结果</span><br><span class="line">                if(tmp != null)&#123;</span><br><span class="line">                    tokenType = tmp;</span><br><span class="line">                    str = text.substring(pos, pos+2);</span><br><span class="line">                    posMove = 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，还需要对注释进行处理，将单行注释与多行注释过滤掉，仅输出有效语法成分。</p>
<h4 id="3-3-Token类"><a href="#3-3-Token类" class="headerlink" title="3.3 Token类"></a>3.3 Token类</h4><h5 id="3-3-1-token"><a href="#3-3-1-token" class="headerlink" title="3.3.1 token"></a>3.3.1 token</h5><p>记录了Token的原字符串，token的类型，以及其所在行号（供错误处理使用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// token/Token.java</span><br><span class="line">public class Token &#123;</span><br><span class="line">    public String str; // 读入的字符串</span><br><span class="line">    public int lineNum;</span><br><span class="line">    public TokenType type;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-文法设定的保存"><a href="#3-3-2-文法设定的保存" class="headerlink" title="3.3.2 文法设定的保存"></a>3.3.2 文法设定的保存</h5><p>位于<code>token/TokenType.java</code></p>
<p>我对于Token的存储方式是一符一类，定义在枚举类<code>TokenType</code>里。</p>
<p>此外，为了便于状态机读取当前字符后的进一步状态转移，我们还需要知道文法中规定的保留字（关键字表）、单&#x2F;双分界符都有哪些。</p>
<p>以上两种信息我都认为是“文法给出的设定”，因此在设计上理应放入一个类中，这使得我们的<code>Lexer</code>类并不会把文法写死在代码里，便于后续期中期末考试修改文法时，快速完成词法分析部分的修改。</p>
<p>举例来说，我们如果要增加switch关键字，那么应该在<code>TokenType.java</code>里做出如下改动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// token/TokenType.java</span><br><span class="line">// 新增Token类型</span><br><span class="line">SWITCHTK(&quot;switch&quot;),</span><br><span class="line">// 加入保留字列表</span><br><span class="line">// 保留字列表</span><br><span class="line">    public static final List&lt;String&gt; reservedTokenList = Arrays.asList(</span><br><span class="line">            &quot;switch&quot;, ...);</span><br></pre></td></tr></table></figure>

<h2 id="4-语法分析"><a href="#4-语法分析" class="headerlink" title="4. 语法分析"></a>4. 语法分析</h2><h4 id="4-1-总体思路"><a href="#4-1-总体思路" class="headerlink" title="4.1 总体思路"></a>4.1 总体思路</h4><p>语法分析的任务是是读入token序列，并分析确定其语法结构，最终生成语法树的过程。</p>
<p>我使用了递归下降分析法来实现语法分析：为每个非终结符编写一个递归子程序，以完成该非终结符所对应的语法成分的分析与识别任务，若正确识别，则可以退出该非终结符号的子程序，返回到上一级的子程序继续分析；若发生错误，即源程序不符合文法，则要进行相应的错误信息报告以及错误处理。</p>
<p>递归下降子程序本质上是在进行最左推导，可能会遇到左递归和回溯的问题。</p>
<h4 id="4-2-递归下降的实现"><a href="#4-2-递归下降的实现" class="headerlink" title="4.2 递归下降的实现"></a>4.2 递归下降的实现</h4><p>递归下降的实现位于<code>frontend/Parser.java</code></p>
<p>具体来说，有两个设计。</p>
<h5 id="4-2-1-nextsym-的封装-matchToken"><a href="#4-2-1-nextsym-的封装-matchToken" class="headerlink" title="4.2.1 nextsym()的封装: matchToken()"></a>4.2.1 <code>nextsym()</code>的封装: <code>matchToken()</code></h5><p>我们知道，语法分析的推进，本质上是终结符识别进度的推进，因此**<code>nextsym</code>的调用时机应当是成功识别一个终结符后<strong>。既然如此，我们为何不</strong>将终结符识别、<code>nextsym</code>（以及后续的错误处理）都封装在一个函数里**呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有匹配最终都会归结到对终结符的匹配上，而取下一个终结符的时机就是上一个终结符被读取时，因此将这两个操作合二为一：</span></span><br><span class="line">    <span class="comment">// 将当前token与指定类型的token相匹配，匹配成功则推进匹配进度pos++，否则进行报错</span></span><br><span class="line">    <span class="comment">// 对于规定的若干错误类型，不予报错，而是记录并进行补全</span></span><br><span class="line">    <span class="keyword">private</span> Token <span class="title function_">matchToken</span><span class="params">(TokenType tokenType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curToken.type == tokenType) &#123;</span><br><span class="line">            <span class="type">Token</span> <span class="variable">tmp</span> <span class="operator">=</span> curToken;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; maxPos) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                curToken = tokens.get(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配失败 尝试匹配错误类型 此处curToken不必再向下滑动</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如此一来，<strong>当我们要接纳（注意不是预读）一个语法成分时，我们可以理所当然地调用该方法</strong>。如果成功，那么向下读取下一个字符串，如果失败则不会读取下一个字符（并尝试进行错误处理）。</p>
<p>这样还可以保证，<strong>任何时候，当前的<code>curToken</code>一定是最新的未接纳的字符</strong>。</p>
<h5 id="4-2-2-子程序"><a href="#4-2-2-子程序" class="headerlink" title="4.2.2 子程序: &lt;非终结符&gt;()"></a>4.2.2 子程序: <code>&lt;非终结符&gt;()</code></h5><p>每一个非终结符都有其递归下降子程序。递归下降子程序的返回值是解析好的语法树结点<code>node</code>类。</p>
<p>递归下降子程序主要进行如下工作：</p>
<ul>
<li>根据FIRST集或者回溯，来选择合适的产生式。</li>
<li><strong>根据产生式依序接纳终结符：调用<code>matchToken()</code></strong></li>
<li><strong>根据产生式依序进行右端非终结符的进一步递归下降分析并接纳：调用相应子程序。</strong></li>
<li>最后构建语法树结点<code>node</code>类，供上一层的子程序取用。</li>
</ul>
<p>以<code>ConstInitVal</code>的子程序为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConstInitVal → ConstExp | &#x27;&#123;&#x27; [ ConstInitVal &#123; &#x27;,&#x27; ConstInitVal &#125; ] &#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">// 后者的first是 LBRACE, 以此进行区分</span></span><br><span class="line">    <span class="keyword">private</span> ConstInitValNode <span class="title function_">ConstInitVal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ConstExpNode</span> <span class="variable">constExpNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">lbraceToken</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayList&lt;ConstInitValNode&gt; constInitValNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Token&gt; commaTokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Token</span> <span class="variable">rbraceToken</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 数组的初始化, 以&#123;开头</span></span><br><span class="line">        <span class="keyword">if</span> (curToken.type == TokenType.LBRACE) &#123;</span><br><span class="line">            lbraceToken = matchToken(TokenType.LBRACE);</span><br><span class="line">            <span class="comment">// 下一个token不是右括号, 那么中间应当含有constinitval</span></span><br><span class="line">            <span class="keyword">if</span> (curToken.type != TokenType.RBRACE) &#123;</span><br><span class="line">                constInitValNodes.add(ConstInitVal());</span><br><span class="line">                <span class="keyword">while</span> (curToken.type == TokenType.COMMA) &#123;</span><br><span class="line">                    commaTokens.add(matchToken(TokenType.COMMA));</span><br><span class="line">                    constInitValNodes.add(ConstInitVal());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论中间是否有数组初始值，都应该匹配右括号</span></span><br><span class="line">            rbraceToken = matchToken(TokenType.RBRACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非数组初始化，仅有一个constexp</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            constExpNode = ConstExp();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstInitValNode</span>(constExpNode, lbraceToken, constInitValNodes, commaTokens, rbraceToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-语法树的结点-node类"><a href="#4-2-3-语法树的结点-node类" class="headerlink" title="4.2.3 语法树的结点:node类"></a>4.2.3 语法树的结点:<code>node</code>类</h5><p>位于<code>node</code>包下。</p>
<p><strong><code>node</code>类是语法分析中，语法树的结点，记录了语法分析的结果</strong>。是贯穿了语法分析、错误处理、中间代码生成的重要类。</p>
<p>对于每一个非终结符，都建立一个<code>node</code>类。所有<code>node</code>类都继承了抽象父类<code>Node</code>。</p>
<p><code>Node</code>规定了所有<code>node</code>类都要实现的三个方法，用于<strong>在遍历语法树时执行相应的动作</strong>（即递归下降时的动作符号）：</p>
<ul>
<li><code>print()</code>方法，透过遍历语法树，输出语法分析结果至文件。</li>
<li><code>check()</code>方法，透过遍历语法树，检查错误并记录。</li>
<li><code>buildIr()</code>方法，透过遍历语法树，生成<code>llvm</code>代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstInitValNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="comment">// 语法树结点记录字段</span></span><br><span class="line">    <span class="keyword">private</span> ConstExpNode constExpNode;</span><br><span class="line">    <span class="keyword">private</span> Token lbraceToken;</span><br><span class="line">    <span class="comment">// 需注意，constInitValNodes比 commaTokens长1</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ConstInitValNode&gt; constInitValNodes;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Token&gt; commaTokens;</span><br><span class="line">    <span class="keyword">private</span> Token rbraceToken;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDims</span><span class="params">(ArrayList&lt;Integer&gt; dims)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dims = dims;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 各维的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; dims;</span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstInitValNode</span><span class="params">(...)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 输出语法分析结果至文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lbraceToken != <span class="literal">null</span>)&#123;</span><br><span class="line">            lbraceToken.print();</span><br><span class="line">            <span class="keyword">if</span>(!constInitValNodes.isEmpty())&#123;</span><br><span class="line">                constInitValNodes.get(<span class="number">0</span>).print();</span><br><span class="line">                <span class="keyword">if</span>(!commaTokens.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;commaTokens.size(); i++)&#123;</span><br><span class="line">                        commaTokens.get(i).print();</span><br><span class="line">                        constInitValNodes.get(i+<span class="number">1</span>).print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rbraceToken.print();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(constExpNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            constExpNode.print();</span><br><span class="line">        &#125;</span><br><span class="line">        printNodeType();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 错误处理</span></span><br><span class="line">    <span class="comment">// ConstInitVal → ConstExp | &#x27;&#123;&#x27; [ ConstInitVal &#123; &#x27;,&#x27; ConstInitVal &#125; ] &#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lbraceToken != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!constInitValNodes.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">for</span>(ConstInitValNode constInitValNode : constInitValNodes)&#123;</span><br><span class="line">                    constInitValNode.check();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(constExpNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            constExpNode.check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间代码生成</span></span><br><span class="line">    <span class="comment">// ConstInitVal → ConstExp | &#x27;&#123;&#x27; [ ConstInitVal &#123; &#x27;,&#x27; ConstInitVal &#125; ] &#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向上传递常量的初始值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@synValue</span> 解析好的初值，ConstInt 或 ConstArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@synValueArray</span>    解析好的展平Value列表   ArrayList&lt;Value&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接向上传递结果</span></span><br><span class="line">        <span class="keyword">if</span>(constExpNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            constExpNode.buildIr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要向下迭代 ConstInitVal, ConstInitVal, ConstInitVal...</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 全局常量数组</span></span><br><span class="line">            <span class="comment">// 需要构建constantInitArray，传递给synValue,用于常量数组的初始化</span></span><br><span class="line">            <span class="comment">// 局部常量数组</span></span><br><span class="line">            <span class="comment">// 需要构建constantInitArray，传递给synValue,用于常量数组的初始化</span></span><br><span class="line">            <span class="comment">// 需要构建展平的Value数组，传递给synValueArray，用于store常量数组的值</span></span><br><span class="line">            ArrayList&lt;Constant&gt; constantInitArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Value&gt; flattenValueArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 一维，说明下层constExpNode != null 且传上来的是ConstInt</span></span><br><span class="line">            <span class="keyword">if</span>(dims.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(ConstInitValNode constInitValNode : constInitValNodes)&#123;</span><br><span class="line">                    constInitValNode.buildIr();</span><br><span class="line">                    constantInitArray.add((ConstInt) Irc.synValue);</span><br><span class="line">                    flattenValueArray.add(Irc.synValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 多维，还需要为下层设置dim 因为下层会进入上边一维的分支，即用到dims</span></span><br><span class="line">            <span class="comment">// 且传上来的是ConstArray</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(ConstInitValNode constInitValNode : constInitValNodes)&#123;</span><br><span class="line">                    constInitValNode.setDims(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(dims.subList(<span class="number">1</span>, dims.size())));</span><br><span class="line">                    constInitValNode.buildIr();</span><br><span class="line">                    constantInitArray.add((ConstArray) Irc.synValue);</span><br><span class="line">                    flattenValueArray.addAll(Irc.synValueArray);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Irc.synValue = <span class="keyword">new</span> <span class="title class_">ConstArray</span>(constantInitArray);</span><br><span class="line">            Irc.synValueArray = flattenValueArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里很可惜的一点是，其实不必记录终结符。因为终结符只在输出语法树时才有用，而在后面的中间代码生成中时，只有非终结符结点才能提供有效信息。</strong>等意识到这一点时，已经完成了语法分析和错误处理，没有进行重构。</p>
<h5 id="4-2-4-语法树的打印-print"><a href="#4-2-4-语法树的打印-print" class="headerlink" title="4.2.4 语法树的打印:print()"></a>4.2.4 语法树的打印:<code>print()</code></h5><p>位于<code>node</code>包的各个<code>node</code>类下。</p>
<p><code>print()</code>方法的含义是，以当前结点为根节点，遍历这个子树并输出其语法分析结果到文件。</p>
<p><strong>我们对于语法树的打印，本质上仍然是对于终结符们的打印</strong>，因此<code>token</code>类亦添加了<code>print()</code>方法。</p>
<p>示例详见上一小节的<code>print()</code>方法，直接无脑对于所有成分进行<code>print</code>即可。</p>
<h4 id="4-3-左递归的处理"><a href="#4-3-左递归的处理" class="headerlink" title="4.3 左递归的处理"></a>4.3 左递归的处理</h4><p>涉及到左递归的文法主要是关于Exp系列的非终结符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddExp -&gt; MulExp | AddExp (&#x27;+&#x27; | &#x27;−&#x27;) MulExp</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-右递归改写"><a href="#4-3-1-右递归改写" class="headerlink" title="4.3.1 右递归改写"></a>4.3.1 右递归改写</h5><p>一个处理方式是将左递归改为右递归，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddExp -&gt; MulExp | MulExp (&#x27;+&#x27; | &#x27;−&#x27;) AddExp</span><br></pre></td></tr></table></figure>

<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220110847759.png" alt="image-20231220110847759"></p>
<p>但如此处理是存在潜在风险的，因为这修改了文法。</p>
<h5 id="4-3-2-扩充的BNF范式"><a href="#4-3-2-扩充的BNF范式" class="headerlink" title="4.3.2 扩充的BNF范式"></a>4.3.2 扩充的BNF范式</h5><p>还有一种处理方式是采用BNF范式，修改了文法，直接丢掉<code>AddExp</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddExp -&gt; MulExp &#123;&#x27;+&#x27; MulExp&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220111136501.png" alt="image-20231220111136501"></p>
<p>这种处理方式依然存在风险，因为后续的所有编译环节都要相应地使用修改后的文法。</p>
<h5 id="4-3-3-我的处理"><a href="#4-3-3-我的处理" class="headerlink" title="4.3.3 我的处理"></a>4.3.3 我的处理</h5><p>我的办法是<strong>在扩充的BNF范式的基础上再进一步，把刚刚拆出来的所有<code>MulExp</code>全部手动组装回左递归的形态</strong>。左递归对于后续的编译部分不再有影响，因为我们的信息已经全部存储在编译器中，不再受到最左推导的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 加减表达式 AddExp → MulExp | AddExp (&#x27;+&#x27; | &#x27;−&#x27;) MulExp</span><br><span class="line">    private AddExpNode AddExp() &#123;</span><br><span class="line">        MulExpNode mulExpNode = MulExp();</span><br><span class="line">        Token opToken = null;</span><br><span class="line">        AddExpNode addExpNode = null;</span><br><span class="line"></span><br><span class="line">        // 存在(&#x27;+&#x27; | &#x27;−&#x27;) 那么捕获外层结构，然后组装回一层层的AddExp</span><br><span class="line">        while(curToken.type == TokenType.PLUS || curToken.type == TokenType.MINU)&#123;</span><br><span class="line">            // 将上一轮捕获的单位进行组装</span><br><span class="line">            addExpNode = new AddExpNode(mulExpNode, opToken, addExpNode);</span><br><span class="line">            // 以(&#x27;+&#x27; | &#x27;−&#x27;) MulExp为单位继续进行捕获</span><br><span class="line">            opToken = matchToken(curToken.type);</span><br><span class="line">            mulExpNode = MulExp();</span><br><span class="line">        &#125;</span><br><span class="line">        return new AddExpNode(mulExpNode, opToken, addExpNode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体来说，先识别一个必有的<code>MulExp</code>，随后每一次都识别一个<code>+MulExp</code>。**每识别到一个<code>+MulExp</code>，我们便将上一轮识别到的<code>AddExp</code>和上一轮识别到的<code>+MulExp</code>组装成本轮的新<code>AddExp</code>**，这样就可以在不破坏文法的情况下，成功识别到该有的语法结构。</p>
<h4 id="4-4-回溯的处理"><a href="#4-4-回溯的处理" class="headerlink" title="4.4 回溯的处理"></a>4.4 回溯的处理</h4><p>对于一般的产生式，我们采用FIRST集来判别即可，但是也有一些不那么友好的产生式，我们难以判别：</p>
<ul>
<li>选择哪个产生式。</li>
<li>产生式中<code>&#123;xxx&#125;</code>的重复部分，到底应该何时结束。</li>
</ul>
<p><strong>重复部分啥时候结束？看看<code>)</code>，<code>]</code>不就好了？事实上，我们在后续错误处理中采取的，补全的错误局部化策略，迫使我们的程序在<code>)</code>，<code>]</code>缺失时依然要正常工作。为解决这个问题，我们只得以循环部的FIRST集来判别</strong>。</p>
<p>回到我们的回溯问题来。</p>
<p><strong>回溯，即FIRST也失灵的情况下，我们被迫跳过某个非终结符，对后面的标志性符号进行分析，从而判断选取的产生式分支的手段。</strong></p>
<p>回溯只产生在<code>Stmt</code>的左值与<code>Exp</code>判别上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stmt -&gt; LVal &#x27;=&#x27; Exp &#x27;;&#x27;</span><br><span class="line">Stmt -&gt; [Exp] &#x27;;&#x27;</span><br><span class="line">Stmt -&gt; LVal &#x27;=&#x27; &#x27;getint&#x27;&#x27;(&#x27;&#x27;)&#x27;&#x27;;&#x27;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>Exp</code>当然可以透过<code>PrimaryExp</code>推出左值<code>LVal</code>，FIRST集失灵。</p>
<p>为此，我们要处理掉碍事的<code>LVal</code>，暴露出后面的<code>=</code>和<code>getint</code>。</p>
<p>回溯主要是采用<code>savePos()</code>和<code>recoverPos()</code>来记录、复原当前游标在token序列的位置。详细代码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> StmtNode <span class="title function_">Stmt</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        StmtNode.StmtType type;</span><br><span class="line">        ArrayList&lt;Boolean&gt; posFlag = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">switch</span> (curToken.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> xxx -&gt;&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="comment">// 余下三种情况：</span></span><br><span class="line">                <span class="comment">//  LVal &#x27;=&#x27; Exp &#x27;;&#x27;</span></span><br><span class="line">                <span class="comment">//  [Exp] &#x27;;&#x27;</span></span><br><span class="line">                <span class="comment">//  LVal &#x27;=&#x27; &#x27;getint&#x27;&#x27;(&#x27;&#x27;)&#x27;&#x27;;&#x27;</span></span><br><span class="line">                <span class="comment">// 其中：左值表达式 LVal → Ident &#123;&#x27;[&#x27; Exp &#x27;]&#x27;&#125;</span></span><br><span class="line">                <span class="comment">//      表达式 Exp → AddExp → MulExp → UnaryExp  → PrimaryExp | Ident   PrimaryExp → &#x27;(&#x27;</span></span><br><span class="line">                <span class="comment">// 直接为分号，则无需进行任何操作</span></span><br><span class="line">                <span class="keyword">if</span> (curToken.type == TokenType.SEMICN) &#123;</span><br><span class="line">                    tokens.add(matchToken(TokenType.SEMICN));</span><br><span class="line">                    type = StmtNode.StmtType.EXP;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 先使用Exp消去LVal和Exp</span></span><br><span class="line">                    savePos();</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;stmt开始进行试探性检验&quot; + curToken);</span></span><br><span class="line">                    <span class="type">ExpNode</span> <span class="variable">expNode</span> <span class="operator">=</span> Exp();</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;stmt检验完成&quot; + curToken);</span></span><br><span class="line">                    <span class="comment">// 直接为分号，应该是Exp</span></span><br><span class="line">                    <span class="keyword">if</span> (curToken.type == TokenType.SEMICN) &#123;</span><br><span class="line">                        nodes.add(expNode);</span><br><span class="line">                        tokens.add(matchToken(TokenType.SEMICN));</span><br><span class="line">                        type = StmtNode.StmtType.EXP;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 非分号，那么进行回溯以读取LVal</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        recoverPos();</span><br><span class="line">                        <span class="type">LValNode</span> <span class="variable">lValNode</span> <span class="operator">=</span> LVal();</span><br><span class="line">                        nodes.add(lValNode);</span><br><span class="line">                        tokens.add(matchToken(TokenType.ASSIGN));</span><br><span class="line">                        <span class="comment">// LVal &#x27;=&#x27; &#x27;getint&#x27;&#x27;(&#x27;&#x27;)&#x27;&#x27;;&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> (curToken.type == TokenType.GETINTTK) &#123;</span><br><span class="line">                            tokens.add(matchToken(TokenType.GETINTTK));</span><br><span class="line">                            tokens.add(matchToken(TokenType.LPARENT));</span><br><span class="line">                            tokens.add(matchToken(TokenType.RPARENT));</span><br><span class="line">                            tokens.add(matchToken(TokenType.SEMICN));</span><br><span class="line">                            type = StmtNode.StmtType.LVALGETINT;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// LVal &#x27;=&#x27; Exp &#x27;;&#x27;</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            nodes.add(Exp());</span><br><span class="line">                            tokens.add(matchToken(TokenType.SEMICN));</span><br><span class="line">                            type = StmtNode.StmtType.LVALASSIGN;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StmtNode</span>(type, tokens, nodes, posFlag);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h2><p>错误处理的作用是诊察出指定的词法、语法和语义错误， 同时要求进行错误局部化处理，并输出错误信息。错误的类型如下：</p>
<table>
<thead>
<tr>
<th>错误类型</th>
<th>错误类别码</th>
<th>解释</th>
<th>对应文法及出错符号 ( … 表示省略该条规则后续部分)</th>
</tr>
</thead>
<tbody><tr>
<td>非法符号</td>
<td>a</td>
<td>格式字符串中出现非法字符报错行号为 <strong><FormatString></strong> 所在行数。</td>
<td><FormatString> → ‘“‘{<Char>}’”</td>
</tr>
<tr>
<td>名字重定义</td>
<td>b</td>
<td>函数名或者变量名在<strong>当前作用域</strong>下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 <strong><Ident></strong> 所在行数。</td>
<td><ConstDef>→<Ident> … <VarDef>→<Ident> … <Ident> … <FuncDef>→<FuncType><Ident> … <FuncFParam> → <BType> <Ident> …</td>
</tr>
<tr>
<td>未定义的名字</td>
<td>c</td>
<td>使用了未定义的标识符报错行号为 <strong><Ident></strong> 所在行数。</td>
<td><LVal>→<Ident> … <UnaryExp>→<Ident> …</td>
</tr>
<tr>
<td>函数参数个数不匹配</td>
<td>d</td>
<td>函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td>
<td><UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’</td>
</tr>
<tr>
<td>函数参数类型不匹配</td>
<td>e</td>
<td>函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的<strong>函数名</strong>所在行数。</td>
<td><UnaryExp>→<Ident>‘(’[<FuncRParams>]‘)’</td>
</tr>
<tr>
<td>无返回值的函数存在不匹配的return语句</td>
<td>f</td>
<td>报错行号为 <strong>‘return’</strong> 所在行号。</td>
<td><Stmt>→‘return’ {‘[’<Exp>’]’}‘;’</td>
</tr>
<tr>
<td>有返回值的函数缺少return语句</td>
<td>g</td>
<td>只需要考虑函数末尾是否存在return语句，<strong>无需考虑数据流</strong>。报错行号为函数<strong>结尾的’}’</strong> 所在行号。</td>
<td><FuncDef> → <FuncType> <Ident> ‘(’ [<FuncFParams>] ‘)’ <Block> <MainFuncDef> → ‘int’ ‘main’ ‘(’ ‘)’ <Block></td>
</tr>
<tr>
<td>不能改变常量的值</td>
<td>h</td>
<td><LVal>为常量时，不能对其修改。报错行号为 <strong><LVal></strong> 所在行号。</td>
<td><Stmt>→<LVal>‘&#x3D;’ <Exp>‘;’ <Stmt>→<LVal>‘&#x3D;’ ‘getint’ ‘(’ ‘)’ ‘;’</td>
</tr>
<tr>
<td>缺少分号</td>
<td>i</td>
<td>报错行号为分号<strong>前一个非终结符</strong>所在行号。</td>
<td><Stmt>,<ConstDecl>及<VarDecl>中的’;’</td>
</tr>
<tr>
<td>缺少右小括号’)’</td>
<td>j</td>
<td>报错行号为右小括号<strong>前一个非终结符</strong>所在行号。</td>
<td>函数调用(<UnaryExp>)、函数定义(<FuncDef>)及<Stmt>中的’)’</td>
</tr>
<tr>
<td>缺少右中括号’]’</td>
<td>k</td>
<td>报错行号为右中括号<strong>前一个非终结符</strong>所在行号。</td>
<td>数组定义(<ConstDef>,<VarDef>,<FuncFParam>)和使用(<LVal>)中的’]’</td>
</tr>
<tr>
<td>printf中格式字符与表达式个数不匹配</td>
<td>l</td>
<td>报错行号为 <strong>‘printf’</strong> 所在行号。</td>
<td><Stmt> →‘printf’‘(’<FormatString>{,<Exp>}’)’‘;’</td>
</tr>
<tr>
<td>在非循环块中使用break和continue语句</td>
<td>m</td>
<td>报错行号为 <strong>‘break’</strong> 与 <strong>’continue’</strong> 所在行号。</td>
<td><Stmt>→‘break’‘;’ <Stmt>→‘continue’‘;’</td>
</tr>
</tbody></table>
<p>错误处理的各个错误类型是相对独立的，彼此之间仅存在一定的联系，可以分别对每一种错误进行处理。在进行错误处理的过程中，我建立了<strong>栈式符号表</strong>。</p>
<p>错误处理相关的项目文件罗列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── frontend	// 前端入口</span><br><span class="line">|	└── Checker.java				// 错误处理入口</span><br><span class="line">├── node		// 用于递归下降的node包</span><br><span class="line">│   └── &lt;文法非终结符&gt;.java			// node类，放置有语法分析、错误处理、ir的递归下降方法	</span><br><span class="line">├── error		// 错误处理</span><br><span class="line">|	└── Error.java					// 错误类</span><br><span class="line">│   └── ErrorHandler.java			// 错误的记录与输出</span><br><span class="line">|	└── ErrorCheckTool.java			// 错误的工厂类</span><br><span class="line">├── symbol		// 错误处理，符号及栈式符号表</span><br><span class="line">│   └── Symbol.java					// 符号类</span><br><span class="line">|	└── SymbolTable.java			// 符号表类</span><br><span class="line">|	└── SymbolTableStack.java		// 栈式符号表类</span><br></pre></td></tr></table></figure>

<h4 id="5-1-符号表"><a href="#5-1-符号表" class="headerlink" title="5.1 符号表"></a>5.1 符号表</h4><h5 id="5-1-1-符号Symbol"><a href="#5-1-1-符号Symbol" class="headerlink" title="5.1.1 符号Symbol"></a>5.1.1 符号Symbol</h5><p>我将符号的类型分为函数符号<code>FuncSymbol</code>和变量符号<code>NumSymbol</code>，二者都继承一个父类<code>Symbol</code>。</p>
<p>对于函数符号，我们额外记录其返回值类型以及形参的Symbol：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuncSymbol</span> <span class="keyword">extends</span> <span class="title class_">Symbol</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FuncReturnType</span>&#123;</span><br><span class="line">        INT, VOID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> FuncReturnType returnType;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NumSymbol&gt; params;    <span class="comment">// 参数符号列表</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于变量符号，由于其只可能是int或者int数组类型，因此我们只需要额外记录其维数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumSymbol</span> <span class="keyword">extends</span> <span class="title class_">Symbol</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> dim;        <span class="comment">// 数组维数 0 1 2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-2-符号表SymbolTable"><a href="#5-1-2-符号表SymbolTable" class="headerlink" title="5.1.2 符号表SymbolTable"></a>5.1.2 符号表SymbolTable</h5><p>对于符号表，我使用<strong>栈式符号表</strong>。在设计之初，我是想要保留一个双向的类似树结构（其实也确实实现了，<strong>但是ir生成时没有采用该符号表</strong>），在使用栈式符号表后保留根节点，这样就可以留下该符号表。具体来说是把下图中的单向边换成双向边：</p>
<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220163717060.png" alt="image-20231220163717060"></p>
<p>每个符号表中，都由<code>TreeMap</code>来存储具体信息，<code>fatherSymbolTable</code>和<code>sonSymbolTables</code>维护父子间的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SymbolTable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;String, Symbol&gt; symbolMap;		<span class="comment">// 符号表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SymbolTable fatherSymbolTable;    			<span class="comment">// 所属的父符号表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;SymbolTable&gt; sonSymbolTables;   <span class="comment">// 所有儿子符号表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node node;    							<span class="comment">// 绑定的node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SymbolTable</span><span class="params">(SymbolTable fatherSymbolTable, Node node)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-3-符号表栈SymbolTableStack"><a href="#5-1-3-符号表栈SymbolTableStack" class="headerlink" title="5.1.3 符号表栈SymbolTableStack"></a>5.1.3 符号表栈SymbolTableStack</h5><p>该类内封装有构建符号表、查符号表的各种方法，以及一个符号表栈<code>Stack</code>。</p>
<p>该类内还有为<code>continue</code>，<code>break</code>，<code>return</code>等对应错误而设置的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SymbolTableStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;SymbolTable&gt; stack;   <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ====================== 栈操作=======================</span></span><br><span class="line">    <span class="comment">// 创建新的符号表并入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(SymbolTable symbolTable)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的node对应的符号表并入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        push(<span class="keyword">new</span> <span class="title class_">SymbolTable</span>(peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将栈顶符号表出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        instance.stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问栈顶元素 如果栈为空那么返回null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SymbolTable <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈顶符号表中添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSymbolToPeek</span><span class="params">(Symbol symbol)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================= 栈查找 =================</span></span><br><span class="line">    <span class="comment">// 检测栈顶符号表是否包含指定名称的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">peekHasSymbol</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查整个栈内是否包含指定名称的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stackHasSymbol</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查整个栈&lt;第一个&gt;指定名称的元素 是否为指定类型。如果没有该元素，也返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stackHasSymbol</span><span class="params">(String name, SymbolType symbolType)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在整个栈内查找并返回第一个指定名称指定类型的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Symbol <span class="title function_">getSymbol</span><span class="params">(String name, SymbolType symbolType)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ================= 循环的处理 =================</span></span><br><span class="line">    <span class="comment">// 记录当前所在的循环深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">circleDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 进入循环相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">inLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance.circleDepth &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enterLoop</span><span class="params">(<span class="type">boolean</span> into)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================= 函数的处理 =================</span></span><br><span class="line">    <span class="comment">// 记录当前是否在一个无返回值的函数内部</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">inVoidFunc</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进入函数定义相关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">inVoidFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance.inVoidFunc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setInVoidFunc</span><span class="params">(<span class="type">boolean</span> inVoidFunc)</span> &#123;</span><br><span class="line">        instance.inVoidFunc = inVoidFunc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-4-入栈新符号表的时机"><a href="#5-1-4-入栈新符号表的时机" class="headerlink" title="5.1.4 入栈新符号表的时机"></a>5.1.4 入栈新符号表的时机</h5><p>在遍历语法树的过程中，于<code>MainFuncDef</code>，<code>FuncDef</code>以及<code>Stmt</code>的<code>StmtType.BLOCK</code>场合下，调用<code>SymbolTableStack</code>中封装好的方法即可入栈新的符号表，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StmtNode.java</span></span><br><span class="line">	<span class="comment">// 如果是要进入Block 那么应当入栈新符号表</span></span><br><span class="line">        <span class="keyword">if</span>(type == StmtType.BLOCK)&#123; SymbolTableStack.push(<span class="built_in">this</span>); &#125;</span><br><span class="line"><span class="comment">// SymbolTableStack.java</span></span><br><span class="line">	<span class="comment">// 创建新的符号表并入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(SymbolTable symbolTable)</span>&#123;</span><br><span class="line">        <span class="comment">// 栈非空，则栈顶元素应当记录当前进入的符号表为son</span></span><br><span class="line">        <span class="keyword">if</span>(!instance.stack.empty())&#123;</span><br><span class="line">            peek().addSon(symbolTable);</span><br><span class="line">        &#125;</span><br><span class="line">        instance.stack.push(symbolTable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的node对应的符号表并入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        push(<span class="keyword">new</span> <span class="title class_">SymbolTable</span>(peek(), node));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-1-5-添加新符号的时机"><a href="#5-1-5-添加新符号的时机" class="headerlink" title="5.1.5 添加新符号的时机"></a>5.1.5 添加新符号的时机</h5><p>在遍历语法树的过程中，于<code>MainFuncDef</code>，<code>FuncDef</code>以及<code>Stmt</code>的<code>StmtType.BLOCK</code>场合下，读取到新符号（变量、常量、函数）时调用<code>SymbolTableStack</code>中封装好的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FuncDefNode.java</span></span><br><span class="line">	<span class="comment">// 构建该函数的符号</span></span><br><span class="line">    <span class="type">FuncSymbol</span> <span class="variable">funcSymbol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FuncSymbol</span>(identToken.str, identToken.lineNum, <span class="built_in">this</span>, returnType, params);</span><br><span class="line">    SymbolTableStack.addSymbolToPeek(funcSymbol);</span><br><span class="line"><span class="comment">// SymbolTableStack.java</span></span><br><span class="line">	<span class="comment">// 向栈顶符号表中添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSymbolToPeek</span><span class="params">(Symbol symbol)</span>&#123;</span><br><span class="line">        peek().addSymbol(symbol);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-错误处理的逻辑"><a href="#5-2-错误处理的逻辑" class="headerlink" title="5.2 错误处理的逻辑"></a>5.2 错误处理的逻辑</h4><h5 id="5-2-1-错误记录方法"><a href="#5-2-1-错误记录方法" class="headerlink" title="5.2.1 错误记录方法"></a>5.2.1 错误记录方法</h5><p>在<code>error/ErrorCheckTool.java</code>内封装有检查当前语境下错误并记录的方法。在遍历到语法树的特定位置时直接调用，即可进行错误处理。</p>
<h5 id="5-2-1-记录错误的接口"><a href="#5-2-1-记录错误的接口" class="headerlink" title="5.2.1 记录错误的接口"></a>5.2.1 记录错误的接口</h5><p>我将所有能够生成并记录错误的方法都统一放置在了<code>error/ErrorCheckTool.java</code>里，调用其中的方法便可（判断并）记录错误，便于后期修改。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测并处理重定义问题 返回其是否未出现重定义问题</span></span><br><span class="line">    <span class="comment">// false: 出现问题</span></span><br><span class="line">    <span class="comment">// true: 未出现问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeAndHandleDuplicateError</span><span class="params">(Token token)</span>&#123;</span><br><span class="line">        <span class="comment">// 在栈顶的符号表中检测是否存在重复定义</span></span><br><span class="line">        <span class="keyword">if</span>(SymbolTableStack.peekHasSymbol(token.str))&#123;</span><br><span class="line">            ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.b, token.lineNum));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-具体错误的处理方法"><a href="#5-2-2-具体错误的处理方法" class="headerlink" title="5.2.2 具体错误的处理方法"></a>5.2.2 具体错误的处理方法</h5><ul>
<li><p><strong>a - 非法符号；l - 字符串<code>%d</code>参数不对应</strong></p>
<p>判断字符串当中是否含有非法字符结构，在遍历到<code>formatStringToken</code>时处理即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StmtNode.java</span></span><br><span class="line"><span class="comment">// &#x27;printf&#x27;&#x27;(&#x27;FormatString&#123;,Exp&#125;&#x27;)&#x27;&#x27;;&#x27;</span></span><br><span class="line">            <span class="keyword">case</span> PRINTF -&gt; &#123;</span><br><span class="line">                <span class="type">Token</span> <span class="variable">formatStringToken</span> <span class="operator">=</span> getFormatStringToken();</span><br><span class="line">                <span class="comment">// 检查字符串本身是否合法</span></span><br><span class="line">                <span class="keyword">if</span>(!checkFormatString(formatStringToken.str))&#123;</span><br><span class="line">                    ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.a, formatStringToken.lineNum));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查%d和实际参数的个数是否对应</span></span><br><span class="line">                <span class="keyword">if</span>(getFormatStringDNum(formatStringToken.str) != nodes.size())&#123;</span><br><span class="line">                    ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.l, formatStringToken.lineNum));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>b 类错误 - 名字重定义</strong></p>
<p>对于题目给出的四条文法，读取到<code>ident</code>的创建时，调用：</p>
<p>时间不是很够了，文档写不完了，截个图吧()</p>
<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220170649806.png" alt="image-20231220170649806"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测并处理重定义问题 返回其是否未出现重定义问题</span></span><br><span class="line">    <span class="comment">// false: 出现问题</span></span><br><span class="line">    <span class="comment">// true: 未出现问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeAndHandleDuplicateError</span><span class="params">(Token token)</span>&#123;</span><br><span class="line">        <span class="comment">// 在栈顶的符号表中检测是否存在重复定义</span></span><br><span class="line">        <span class="keyword">if</span>(SymbolTableStack.peekHasSymbol(token.str))&#123;</span><br><span class="line">            ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.b, token.lineNum));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>c 类错误 - 未定义的名字</strong></p>
<p>对于题目给出的三条文法，读取到<code>ident</code>的引用时，调用：</p>
<p>时间不是很够了，文档写不完了，截个图吧()</p>
<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231220170735682.png" alt="image-20231220170735682"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测并处理无定义问题 返回其是否未出现无定义问题</span></span><br><span class="line">    <span class="comment">// false: 出现问题</span></span><br><span class="line">    <span class="comment">// true: 未出现问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeAndHandleUndefinedError</span><span class="params">(Token token)</span>&#123;</span><br><span class="line">        <span class="comment">// 在栈顶的符号表中检测是否存在定义</span></span><br><span class="line">        <span class="keyword">if</span>(!SymbolTableStack.stackHasSymbol(token.str))&#123;</span><br><span class="line">            ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.c, token.lineNum));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>d 类错误 - 函数参数个数不匹配</strong></p>
<p>对于题目给出的文法，当<code>UnaryExp</code>需要进行函数调用时，从符号表得到其形参个数，再读取其子节点的<code>funcRParamsNode</code>的<code>expNodes</code>的<code>size()</code>，两者比较，如果不同，那就报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先检查符号未定义c</span></span><br><span class="line">            <span class="keyword">if</span>(ErrorCheckTool.judgeAndHandleUndefinedError(identToken))&#123;</span><br><span class="line">                <span class="comment">// 检查其是否为函数符号 如果不是 则报参数个数错误</span></span><br><span class="line">                <span class="type">FuncSymbol</span> <span class="variable">symbol</span> <span class="operator">=</span> (FuncSymbol) SymbolTableStack.getSymbol(identToken.str, SymbolType.Function);</span><br><span class="line">                <span class="keyword">if</span>(symbol == <span class="literal">null</span>)&#123;</span><br><span class="line">                    ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.d, identToken.lineNum));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检测参数个数是否一致</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(symbol.getParams().size() != getParamsNum())&#123;</span><br><span class="line">                    ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.d, identToken.lineNum));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检验参数类型是否一一对应</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!checkParamsSame(symbol))&#123;</span><br><span class="line">                    ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(ErrorType.e, identToken.lineNum));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>e 类错误 - 函数参数类型不匹配</strong></p>
<p>我们的变量类型只有三种：整型、一维数组、二维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检验参数类型是否一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkParamsSame</span><span class="params">(FuncSymbol symbol)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(funcRParamsNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> symbol.getParams().size() == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;NumSymbol&gt; fParams = symbol.getParams();</span><br><span class="line">            ArrayList&lt;ExpNode&gt; expNodes = funcRParamsNode.getExpNodes();</span><br><span class="line">            <span class="type">int</span> fParamDim, rParamDim;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; symbol.getParams().size(); i++)&#123;</span><br><span class="line">                fParamDim = fParams.get(i).getDim();    <span class="comment">// 形参维数</span></span><br><span class="line">                rParamDim = expNodes.get(i).getDim();   <span class="comment">// 实参维数</span></span><br><span class="line">                <span class="comment">// -2代表维数不确定（即实参未定义），此处不处理，留到后面报出错误c</span></span><br><span class="line">                <span class="keyword">if</span>(rParamDim != -<span class="number">2</span> &amp;&amp; fParamDim != rParamDim)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于函数形参，我们已经在创建函数符号时记录了其维度信息，直接取用，</p>
<p>对于函数实参，需要现查维数，即从<code>ExpNode</code>开始一个小小的递归查找。</p>
<p>能够贡献出维数信息的结点主要是：</p>
<ul>
<li><p><code>UnaryExpNode</code>：UnaryExp → Ident ‘(‘ [FuncRParams] ‘)’。直接采取函数返回值</p>
</li>
<li><p><code>PrimaryExp </code>Node：PrimaryExp → Number。Number的维数是0</p>
</li>
<li><p><code>LValNode</code>：LVal → Ident {‘[‘ Exp ‘]’} &#x2F;&#x2F;1.普通变量 2.一维数组 3.二维数组。根据符号表中查得的<code>Ident</code>维数，减去数组取值的维数即可。</p>
</li>
</ul>
</li>
<li><p><strong>f 类错误 - 无返回值的函数存在不匹配的<code>return</code>语句；g 类错误 - 有返回值的函数缺少<code>return</code>语句</strong></p>
<p>在<code>stmt</code>的类型是<code>Return</code>时，如果在函数当中但<code>expNode != null</code>就报错。</p>
</li>
<li><p><strong>h 类错误 - 不能改变常量的值</strong></p>
<p>判断<code>&lt;LVal&gt;</code>当中的<code>&lt;ident&gt;</code>是否是常量即可。</p>
</li>
<li><p><strong>i j k 类错误 - 缺少分号、缺少右小括号’)’、缺少右中括号’]’</strong></p>
<p>在语法分析部分的<code>matchToken()</code>函数处理，并进行补全的错误局部化处理即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Token <span class="title function_">matchToken</span><span class="params">(TokenType tokenType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curToken.type == tokenType) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配失败 尝试匹配错误类型 此处curToken不必再向下滑动</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tokenType == TokenType.SEMICN || tokenType == TokenType.RPARENT || tokenType == TokenType.RBRACK)&#123;</span><br><span class="line">            <span class="comment">// 此处应该返回前一个非终结符的位置 这里前一个非终结符一定不为空</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">lineNum</span> <span class="operator">=</span> tokens.get(pos-<span class="number">1</span>).lineNum;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> tokenType.getStr();</span><br><span class="line">            <span class="type">ErrorType</span> <span class="variable">errorType</span> <span class="operator">=</span> tokenErrorMap.get(tokenType);</span><br><span class="line">            ErrorHandler.addError(<span class="keyword">new</span> <span class="title class_">Error</span>(errorType, lineNum));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Token</span>(str, lineNum, tokenType);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>m 类错误 - 在非循环块中使用 <code>break</code> 和 <code>continue</code> 语句</strong></p>
<p>我们在符号表栈内维护了<code>loopCount</code>，初始为 0，每次进入循环就加一，退出循环就减一。</p>
<p>在 <code>stmt</code> 的类型是 <code>Break</code> 或者 <code>Continue</code> 时，判断当前的 <code>loopCount</code> 是否为零即可，如果是，那就报错。</p>
</li>
</ul>
<h2 id="6-中间代码生成与优化"><a href="#6-中间代码生成与优化" class="headerlink" title="6. 中间代码生成与优化"></a>6. 中间代码生成与优化</h2><p>LLVM是一种三地址码，即一条LLVM语句可以表示为如下形式：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;运算结果&gt; <span class="operator">=</span> &lt;指令类型&gt; &lt;操作数<span class="number">1</span>&gt;<span class="punctuation">,</span> &lt;操作数<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>

<p>观察这种指令可以发现，一条语句主要由三个要素组成：</p>
<p>（1）操作数（2）指令类型（3）运算结果</p>
<p>现在<strong>我们需要将LLVM的这种语言特性，使用Java的类设计来表达</strong>：</p>
<ol>
<li><strong>在Java代码中，使用具体的类对象，来表示语句中的各个元素</strong>。（就像语法分析中使用各种<code>node</code>类来表达各种语法元素一样）</li>
<li>具体措施是，<strong>通过遍历之前语法分析的语法树，透过结合属性翻译文法的递归下降的方式，来生成llvm的语法树</strong>。</li>
</ol>
<h4 id="6-1-对LLVM的简单理解"><a href="#6-1-对LLVM的简单理解" class="headerlink" title="6.1 对LLVM的简单理解"></a>6.1 对LLVM的简单理解</h4><p>我们将<code>llvm</code>采用树的形式存储，根节点为<code>Module</code>。</p>
<ul>
<li>一个 <code>module</code> 中可以拥有两种顶层实体： <code>Function</code> 和 <code>GlobalVariable</code></li>
<li>每个 <code>Function</code> 下都有若干基本块 <code>BasicBlock</code></li>
<li>每个 <code>BasicBlock</code>下都有若干指令 <code>instruction</code></li>
</ul>
<p>在以上结构中，关键节点类的设计如下：</p>
<p><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/image-20231110104112393.png" alt="image20231110104112393"></p>
<p><strong>空心粗箭头表示类继承关系</strong>（User和Value类也是继承关系，图应该是画错了）。</p>
<p><strong>实心细箭头表示聚合关系，从而形成树结构</strong>（例如每一个基本块<code>BasicBlock</code>里有一条条指令<code>Instruction</code>）。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;运算结果&gt; <span class="operator">=</span> &lt;指令类型&gt; &lt;操作数<span class="number">1</span>&gt;<span class="punctuation">,</span> &lt;操作数<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-1-操作数-Value类"><a href="#6-1-1-操作数-Value类" class="headerlink" title="6.1.1 操作数 Value类"></a>6.1.1 操作数 Value类</h5><p>将操作数表示为一个类：Value，它<strong>表示能够作为操作数的对象</strong>。</p>
<p>例如如下乘法语句中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%2 = mul i32 %1, 2</span><br></pre></td></tr></table></figure>

<p>按照上面的设计，**<code>%1</code>和<code>2</code>都是Value，在Java代码中都以Value类的形式存在**。</p>
<h5 id="6-1-2-操作数使用者-User类"><a href="#6-1-2-操作数使用者-User类" class="headerlink" title="6.1.2 操作数使用者 User类"></a>6.1.2 操作数使用者 User类</h5><p>将指令的运算结果表示为一个类：User，它<strong>表示能够作为运算结果的对象，或者说是操作数的使用者</strong>。</p>
<p>例如如下乘法语句中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%2 = mul i32 %1, 2</span><br></pre></td></tr></table></figure>

<p>按照上面的设计，<code>%2</code>是User，它<code>use</code>了<code>%1</code>和<code>2</code>。**<code>%2</code>在Java代码中以User类的形式存在**。</p>
<h5 id="6-1-3-User类继承Value类"><a href="#6-1-3-User类继承Value类" class="headerlink" title="6.1.3 User类继承Value类"></a>6.1.3 User类继承Value类</h5><p>观察如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%2 = mul i32 %1, 2	</span><br><span class="line">%3 = add i32 %2, 3	</span><br></pre></td></tr></table></figure>

<p>乘法产生的<code>%2</code><strong>运算结果</strong>在下一条加法语句中<strong>作为了操作数</strong>。<code>User</code>类应该继承<code>Value</code>类，这样后面的运算才能用到前面的结果。</p>
<h5 id="6-1-4-指令-Instruction类"><a href="#6-1-4-指令-Instruction类" class="headerlink" title="6.1.4 指令 Instruction类"></a>6.1.4 指令 Instruction类</h5><p>为每一种指令类型都创建一个<code>Instruction</code>指令类，这个<strong>指令类继承<code>User</code>，既用来表示运算结果，也用来表示这一条指令</strong>。</p>
<p>如何理解”既用来表示运算结果，也用来表示这一条指令”？</p>
<p>回到<code>2.User类</code>的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%2 = mul i32 %1, 2</span><br></pre></td></tr></table></figure>

<p>在代码实现当中，**<code>%2</code>是一个<code>Mul</code>指令类对象**。</p>
<ul>
<li>它既<strong>表示<code>%2</code>这个运算结果</strong>：Mul extends User，这意味着这个<code>Mul</code>类对象可以表示运算结果；User extends Value，这意味着这个<code>Mul</code>类对象还可以作为操作数。</li>
<li>又<strong>表示这条语句本身</strong>：Mul类是llvm语法树中，挂在BasicBlock下的一个节点，通过遍历语法树，并调用<code>toString()</code>方法，即可从这个Mul类中取出目标代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mul</span> <span class="keyword">extends</span> <span class="title class_">Instruction</span>&#123;	<span class="comment">// Instruction继承User</span></span><br><span class="line">    <span class="comment">// 构造方法，记录这条Mul指令的各个要素</span></span><br><span class="line">    <span class="comment">// 包括其名字(例如&quot;%2&quot;),所属基本块，操作数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mul</span><span class="params">(String name, BasicBlock parent, Value op1, Value op2)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, parent, op1, op2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成目标代码的字符串</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAresIrString(<span class="string">&quot;mul&quot;</span>);	<span class="comment">// 一个用来计算形如`&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;`的目标代码字符串的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，如下中间代码，将其翻译为Java代码，可以是：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="variable">%1</span></span><br><span class="line">// IrBuilder.buildxxx是封装了具体操作的工厂模式方法，</span><br><span class="line">// 其参数是操作数Value类，返回结果是计算结果Instruction类</span><br><span class="line">Mul <span class="keyword">mul</span><span class="number">1</span> <span class="operator">=</span> IrBuilder.buildMulInstruction(new ConstInt(<span class="number">1</span>)<span class="punctuation">,</span> new ConstInt(<span class="number">1</span>))</span><br><span class="line">Mul <span class="keyword">mul</span><span class="number">2</span> <span class="operator">=</span> IrBuilder.buildMulInstruction(<span class="keyword">mul</span><span class="number">2</span><span class="punctuation">,</span> <span class="keyword">mul</span><span class="number">2</span>)    </span><br></pre></td></tr></table></figure>

<p>常用的llvm指令罗列如下：</p>
<table>
<thead>
<tr>
<th>llvm ir</th>
<th>usage</th>
<th>intro</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>&#x2F;</td>
</tr>
<tr>
<td>sub</td>
<td><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>&#x2F;</td>
</tr>
<tr>
<td>mul</td>
<td><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>&#x2F;</td>
</tr>
<tr>
<td>sdiv</td>
<td><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>有符号除法</td>
</tr>
<tr>
<td>icmp</td>
<td><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>比较指令</td>
</tr>
<tr>
<td>and</td>
<td><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>与</td>
</tr>
<tr>
<td>or</td>
<td><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</code></td>
<td>或</td>
</tr>
<tr>
<td>call</td>
<td><code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;fnptrval&gt;(&lt;function args&gt;)</code></td>
<td>函数调用</td>
</tr>
<tr>
<td>alloca</td>
<td><code>&lt;result&gt; = alloca &lt;type&gt;</code></td>
<td>分配内存</td>
</tr>
<tr>
<td>load</td>
<td><code>&lt;result&gt; = load &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt;</code></td>
<td>读取内存</td>
</tr>
<tr>
<td>store</td>
<td><code>store &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;</code></td>
<td>写内存</td>
</tr>
<tr>
<td>getelementptr</td>
<td><code>&lt;result&gt; = getelementptr &lt;ty&gt;, * &#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</code> <code>&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</code></td>
<td>计算目标元素的位置（仅计算）</td>
</tr>
<tr>
<td>phi</td>
<td><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [ &lt;val0&gt;, &lt;label0&gt;], ...</code></td>
<td>在 SSA 时需要考虑的</td>
</tr>
<tr>
<td>zext..to</td>
<td><code>&lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;</code></td>
<td>类型转换，将 <code>ty</code>的<code>value</code>的type转换为<code>ty2</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>llvm ir</th>
<th>usage</th>
<th>intro</th>
</tr>
</thead>
<tbody><tr>
<td>br</td>
<td><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code> <code>br label &lt;dest&gt;</code></td>
<td>改变控制流</td>
</tr>
<tr>
<td>ret</td>
<td><code>ret &lt;type&gt; &lt;value&gt;</code> ,<code>ret void</code></td>
<td>退出当前函数，并返回值（可选）</td>
</tr>
</tbody></table>
<p>我在 LLVM IR 当中，给每条指令都写了一个类（Binary 指的是诸如 add sub mul 这样的二元指令），为了方便我对每种类型的指令进行管理和输出。</p>
<h5 id="6-1-5-特殊的Value类：Function和BasicBlock类"><a href="#6-1-5-特殊的Value类：Function和BasicBlock类" class="headerlink" title="6.1.5 特殊的Value类：Function和BasicBlock类"></a>6.1.5 特殊的Value类：Function和BasicBlock类</h5><p><code>Function</code>和<code>BasicBlock</code>类也可以作为操作数。</p>
<p>例如调用指令：<code>&lt;result&gt; = call [ret attrs] &lt;ty&gt; &lt;fnptrval&gt;(&lt;function args&gt;)</code>的实现上，我们直接将function作为了一个操作数，用来构建Call指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在符号表中找到需要的Function类对象</span></span><br><span class="line"><span class="type">Function</span> <span class="variable">function</span> <span class="operator">=</span> (Function) IrSymbolTableStack.getSymbol(identToken.str);</span><br><span class="line"><span class="comment">// 实参所对应的Value类对象的列表</span></span><br><span class="line">ArrayList&lt;Value&gt; argRValues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line"><span class="comment">// 使用封装好的方法来构建Call指令</span></span><br><span class="line"><span class="comment">// Irc.synValue全称是IrContext.synthesizeValue</span></span><br><span class="line"><span class="comment">// IrContext里面记录了一些全局变量（综合属性），用来在递归下降中，进行不同下降层级之间的通信</span></span><br><span class="line"><span class="comment">// （例如AddExp可以向下递归到MulExp，根据文法，AddExp依赖于MulExp的计算结果，下层的MulExp可以通过Irc.synxxx来将这个结果传递给上层的AddExp）</span></span><br><span class="line">Irc.synValue = IrBuilder.buildCallInstruction(function, argRValues, Irc.curBlock);</span><br></pre></td></tr></table></figure>

<h5 id="6-1-6-根节点：Module类"><a href="#6-1-6-根节点：Module类" class="headerlink" title="6.1.6 根节点：Module类"></a>6.1.6 根节点：Module类</h5><p>如同编译单元一样的存在，LLVM IR 文件的基本单位称为 <code>module</code>，我们的实验只有单<code>module</code>。</p>
<h4 id="6-2-架构设计"><a href="#6-2-架构设计" class="headerlink" title="6.2 架构设计"></a>6.2 架构设计</h4><p><code>llvm</code>生成及优化的流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IrBuilder.java</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ============ 生成中间代码 ============</span></span><br><span class="line">        compUnitNode.buildIr();             <span class="comment">// 生成中间代码</span></span><br><span class="line">        <span class="comment">// ===== 中间代码分析 与 目标代码预处理 =====</span></span><br><span class="line">        DeadCodeRemove.analyze();           <span class="comment">// 简单的死代码删除</span></span><br><span class="line">        ControlFlowGraphAnalyzer.analyze(); <span class="comment">// 控制流图构建</span></span><br><span class="line">        DomainTreeAnalyzer.analyze();       <span class="comment">// domain树生成</span></span><br><span class="line">        LoopAnalyzer.analyze();             <span class="comment">// 循环分析</span></span><br><span class="line">        <span class="keyword">if</span> (Config.openMem2RegOpt) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Mem2Reg</span>().analyze();            <span class="comment">// Mem2Reg重构带有phi的SSA</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与中间代码生成有关的项目文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node		// 用于递归下降的node包</span><br><span class="line">│   └── &lt;文法非终结符&gt;.java			// node类，放置有语法分析、错误处理、ir的递归下降方法	</span><br><span class="line">├── ir			// 中间代码生成与优化</span><br><span class="line">|   ├── analyze				// 中间代码优化</span><br><span class="line">|   ├── types				// value的类型</span><br><span class="line">|   ├── values				// values</span><br><span class="line">|   |	└── constants				// Constant value们</span><br><span class="line">|   │   └── instructions			// Instruction value们</span><br><span class="line">|   |	└── BasicBlock.java			</span><br><span class="line">|   |	└── Function.java			</span><br><span class="line">|   |	└── GlobalVariable.java	</span><br><span class="line">|   |	└── Module.java	</span><br><span class="line">|   |	└── Value.java	</span><br><span class="line">|   |	└── User.java		</span><br><span class="line">|   ├── Irc.java					// 在中间代码生成中保存上下文信息</span><br><span class="line">│   ├── Irbuilder.java				// 中间代码的入口类及工厂类</span><br></pre></td></tr></table></figure>

<h5 id="6-2-1-node类们：递归下降的具体实现者"><a href="#6-2-1-node类们：递归下降的具体实现者" class="headerlink" title="6.2.1 node类们：递归下降的具体实现者"></a>6.2.1 node类们：递归下降的具体实现者</h5><p>node类们内都实现了抽象父类的<code>buildIr()</code>方法，<strong>用以进行基于属性翻译文法的递归下降。中间代码生成的具体逻辑都存于各种node中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIr</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-2-IrBuilder类：指令的工厂"><a href="#6-2-2-IrBuilder类：指令的工厂" class="headerlink" title="6.2.2 IrBuilder类：指令的工厂"></a>6.2.2 IrBuilder类：指令的工厂</h5><p>IrBuilder类是中间代码的入口，同时也<strong>封装有构建<code>llvm</code>元素的工厂模式方法</strong>。</p>
<p>举例来说，我们现在正要取出一个指针类型变量所指空间中的内容，可以构建一条<code>Load</code>指令（当然如果是数组就需要GEP指令了），并将其插入当前所处的基本块。可以如此做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LValNode.java，其对应文法LVal → Ident &#123;&#x27;[&#x27; Exp &#x27;]&#x27;&#125;，是指针的发祥地</span></span><br><span class="line"><span class="comment">// 取出该指针指向空间的内容</span></span><br><span class="line">      <span class="type">Value</span> <span class="variable">fParamValue</span> <span class="operator">=</span> IrBuilder.buildLoadInstruction(lvalValue, Irc.curBlock);</span><br><span class="line">      <span class="comment">// 没有[]，则直接原封不动传回，因为这就是形参</span></span><br><span class="line">      <span class="keyword">if</span>(expNodes.isEmpty())&#123;</span><br><span class="line">          Irc.synValue = fParamValue;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// IrBuilder.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建加载指令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pointer 要加载的地址，从这个地址处读取操作数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 完成加载的Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Load <span class="title function_">buildLoadInstruction</span><span class="params">(Value pointer, BasicBlock parent)</span> &#123;</span><br><span class="line">        <span class="type">Load</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Load</span>(getNameString(), parent, pointer);</span><br><span class="line">        parent.addInstruction(load);</span><br><span class="line">        <span class="keyword">return</span> load;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-2-3-Irc类：递归下降的上下文信息"><a href="#6-2-3-Irc类：递归下降的上下文信息" class="headerlink" title="6.2.3 Irc类：递归下降的上下文信息"></a>6.2.3 Irc类：递归下降的上下文信息</h5><p>刚刚我们提到，要进行基于属性翻译文法的递归下降。既然是属性翻译文法，势必涉及到<strong>综合属性（<code>synthesized attribute</code>)的向上传递</strong>，以及<strong>继承属性（<code>inherited attribute</code>）的向下传递</strong>。</p>
<p>得益于递归下降的方法，我们可以直接在<code>node</code>类内，通过父子<code>node</code>间直接调用对方的相关<code>setter</code>或者<code>getter</code>来粗暴地实现信息传递。</p>
<p>但如果我们传递的链条很长呢？譬如我们在一个<code>LVal</code>内的信息，要经过好长好长的路，才能抵达真正需要该信息的<code>ConstExp</code>，这时候如果还要写那么多<code>setter</code>，未免也过于笨。</p>
<p>考虑到只有综合属性会出现这种长线的传递，我们可以在<code>Irc</code>里直接记录全局的，正在传递的综合属性（们）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=========================== 综合属性 =================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value类型列表的综合属性 up向上传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Value&gt; synValueArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value类型的综合属性 up向上传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Value</span> <span class="variable">synValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int类型的综合属性 up向上传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">synInt</span> <span class="operator">=</span> -<span class="number">1190</span>;</span><br></pre></td></tr></table></figure>

<p><strong>中间代码的构建过程，是字面意义上拆东墙建西墙的过程，即在根据文法递归下降 扫描语法分析结果的同时，在另一边逐步（用动作符号）搭建起另一个<code>llvm</code>的体系。</strong></p>
<p>既然是同步在扫描两个体系，就应当有两组指针来记录扫描进度。<strong>语法分析的扫描进度（由递归下降保证外，还有当前是否在扫描常量表达式，是否在扫描函数实参，是否正在经历循环），<code>llvm</code>的构建进度（即当前在搭建哪个函数，哪个基本块，）都应当得到记录</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前所在基本块</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">BasicBlock</span> <span class="variable">curBlock</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前所在函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Function</span> <span class="variable">curFunction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前是否正在计算 无变量常数表达式</span></span><br><span class="line"><span class="comment">    * 如果是，那么综合属性只需要传递syvInt，且计算情况有所减少</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isBuildingConstExp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前是否在进行全局变量的初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isBuildingGlobalInit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  当前是否正在构建一个int类型的实参</span></span><br><span class="line"><span class="comment">    *  如果是，但是当前解析到的却是int*类型，那么需要load</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isBuildingPointerRParam</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理多重循环中的continue，</span></span><br><span class="line"><span class="comment">    * 栈顶的loopEndBlock即是当前层Continue跳转的对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;BasicBlock&gt; loopEndBlockStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理多次循环中的break</span></span><br><span class="line"><span class="comment">    * 栈顶的endBlock即是当前层break跳转的对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;BasicBlock&gt; endBlockStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="6-2-4-llvm元素"><a href="#6-2-4-llvm元素" class="headerlink" title="6.2.4 llvm元素"></a>6.2.4 <code>llvm</code>元素</h5><p><code>llvm</code>元素主要放置在<code>ir/values</code>内。</p>
<p>该类主要存储了<code>llvm</code>体系下，该元素的要素及其相应的<code>getter</code>和<code>setter</code>。</p>
<p>此外，所有<code>llvm</code>元素都实现了<code>buildMips()</code>方法（及辅助方法），用于后续构建<code>mips</code>体系。</p>
<p>因此，**<code>llvm</code>元素类是贯穿了<code>llvm</code>初步生成，中端的<code>mem2reg</code>重构，<code>mips</code>初步生成**的重要类。</p>
<p>举例来说，我们在基本块<code>BasicBlock</code>类内，会记录这样的一些信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指令序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Instruction&gt; instructions = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前驱与后继块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;BasicBlock&gt; preBlocks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;BasicBlock&gt; sucBlocks = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支配者块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;BasicBlock&gt; domers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-3-SSA初步处理"><a href="#6-3-SSA初步处理" class="headerlink" title="6.3 SSA初步处理"></a>6.3 SSA初步处理</h4><h5 id="6-3-1-SSA的概念"><a href="#6-3-1-SSA的概念" class="headerlink" title="6.3.1 SSA的概念"></a>6.3.1 SSA的概念</h5><p><strong>静态单赋值</strong>（Static Single Assignment, <strong>SSA</strong>）是编译器中间表示中的一种变量的命名约定。当程序中的每个变量都有且只有一个赋值语句时，称一个程序是 SSA 形式的。</p>
<p><strong>在<code>llvm</code>中，每个变量都在使用前都必须先定义，且每个变量只能被赋值一次（每个变量只能被初始化，不能被赋值）</strong>。</p>
<p>举例来说，如果想要返回 <code>1 * 2 + 3</code> 的值，我们下意识地就会像这样写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LLVM</span><br><span class="line">%0 = mul i32 1, 2</span><br><span class="line">%0 = add i32 %0, 3</span><br><span class="line">ret i32 %0</span><br></pre></td></tr></table></figure>

<p>但这样写实际上是错的，因为变量 <code>%0</code> 被赋值了两次。我们需要修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LLVM</span><br><span class="line">%0 = mul i32 1, 2</span><br><span class="line">%1 = add i32 %0, 3</span><br><span class="line">ret i32 %1</span><br></pre></td></tr></table></figure>

<h5 id="6-3-2-phi形式的SSA与逃课形式的SSA"><a href="#6-3-2-phi形式的SSA与逃课形式的SSA" class="headerlink" title="6.3.2 phi形式的SSA与逃课形式的SSA"></a>6.3.2 phi形式的SSA与逃课形式的SSA</h5><p>当涉及到分支语句时，SSA会遇到一些问题，以下面这个循环为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    i = getint();</span><br><span class="line">    int a = 1;</span><br><span class="line">    a = getint();</span><br><span class="line">    for(; i &lt; 10; i = i + 1)&#123;</span><br><span class="line">    	i = i + 2;</span><br><span class="line">        a = a + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会发现，对于循环的归纳变量，其注定会有两处赋值。因此同样对于<code>i</code>和<code>a</code>，我们需要再来一个<code>i1</code>和<code>a1</code>来放置这第二个赋值。</p>
<p>那么问题来了，在<code>i1</code>和<code>a1</code>的汇聚点，到底该采取哪个赋值？这时候就必须用到<code>phi</code>指令。</p>
<p><code>phi</code> 指令这个指令能够根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = phi &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], [&lt;val1&gt;, &lt;label1&gt;] ...</span><br></pre></td></tr></table></figure>

<p>有了<code>phi</code>，我们就可以写出代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @main() &#123;</span><br><span class="line">b0:</span><br><span class="line">	%i3 = call i32 @getint()</span><br><span class="line">	%i7 = call i32 @getint()</span><br><span class="line">	br label %b9</span><br><span class="line">b9:</span><br><span class="line">	%p25 = phi i32 [ %i3, %b0 ],  [ %i16, %b11 ]</span><br><span class="line">	%p24 = phi i32 [ %i7, %b0 ],  [ %i19, %b11 ]</span><br><span class="line">	%i14 = icmp slt i32 %p25, 10</span><br><span class="line">	br i1 %i14, label %b10, label %b12</span><br><span class="line">b10:</span><br><span class="line">	%i19 = add i32 %p24, 2</span><br><span class="line">	%i22 = add i32 %p25, 3</span><br><span class="line">	br label %b11</span><br><span class="line">b11:</span><br><span class="line">	%i16 = add i32 %i22, 1</span><br><span class="line">	br label %b9</span><br><span class="line">b12:</span><br><span class="line">	ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上，<code>phi</code>指令的构建有亿点点复杂，这也太难写了！如果有一个能够摆脱SSA限制的办法就好了。</p>
<p>虽然不能直接赋值，但是假如<strong>我的局部变量都存储在指针指向的地址内，我每一次给变量赋值，其实都是在写地址</strong>呢？<del>这就是<code>llvm</code>ts<code>SSA</code>zy</del>！这样就摆脱了SSA的单一赋值限制！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @main() &#123;</span><br><span class="line">b0:</span><br><span class="line">	%i5 = alloca i32</span><br><span class="line">	%i1 = alloca i32</span><br><span class="line">	store i32 0, i32* %i1</span><br><span class="line">	%i3 = call i32 @getint()</span><br><span class="line">	store i32 %i3, i32* %i1</span><br><span class="line">	store i32 1, i32* %i5</span><br><span class="line">	%i7 = call i32 @getint()</span><br><span class="line">	store i32 %i7, i32* %i5</span><br><span class="line">	br label %b9</span><br><span class="line">b9:</span><br><span class="line">	%i13 = load i32, i32* %i1</span><br><span class="line">	%i14 = icmp slt i32 %i13, 10</span><br><span class="line">	br i1 %i14, label %b10, label %b12</span><br><span class="line">b10:</span><br><span class="line">	%i18 = load i32, i32* %i5</span><br><span class="line">	%i19 = add i32 %i18, 2</span><br><span class="line">	store i32 %i19, i32* %i5</span><br><span class="line">	%i21 = load i32, i32* %i1</span><br><span class="line">	%i22 = add i32 %i21, 3</span><br><span class="line">	store i32 %i22, i32* %i1</span><br><span class="line">	br label %b11</span><br><span class="line">b11:</span><br><span class="line">	%i15 = load i32, i32* %i1</span><br><span class="line">	%i16 = add i32 %i15, 1</span><br><span class="line">	store i32 %i16, i32* %i1</span><br><span class="line">	br label %b9</span><br><span class="line">b12:</span><br><span class="line">	ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-2-局部变量的逃课SSA实现"><a href="#6-3-2-局部变量的逃课SSA实现" class="headerlink" title="6.3.2 局部变量的逃课SSA实现"></a>6.3.2 局部变量的逃课SSA实现</h5><p>这种生成存取内存的<code>llvm</code>有四个特点：</p>
<ul>
<li><p>每个局部变量都变为了栈上分配的空间（变量在符号表中存的其实是其 <code>alloca</code> 指令）</p>
</li>
<li><p>每次对局部变量的读都变成了从内存空间中的一次读（在<code>LValNode</code>中实现，这也是为什么这里是指针的故乡之一！）</p>
</li>
<li><p>每次对局部变量的写都变成了对内存的一次写（每次更新一个变量的值都变成了通过 <code>store</code> 对变量所在内存的写）</p>
</li>
<li><p>获取局部变量的地址等价于获取内存的地址</p>
</li>
</ul>
<p>需要进行的主要操作有：</p>
<ul>
<li><p>局部变量定义时：</p>
<ul>
<li><p><strong><code>alloca</code>（分配变量的栈空间，返回指向该空间的指针）</strong></p>
</li>
<li><p>将<code>alloca</code>记录进入符号表。</p>
</li>
<li><p><strong><code>store</code>（给变量赋值，即向指针所指空间内进行写）</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VarDefNode.java</span></span><br><span class="line"><span class="comment">// 1.2 局部非数组变量</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 分配空间</span></span><br><span class="line">                <span class="type">Alloca</span> <span class="variable">alloca</span> <span class="operator">=</span> IrBuilder.buildAllocaInstruction(<span class="keyword">new</span> <span class="title class_">IntType</span>(<span class="number">32</span>), Irc.curBlock);</span><br><span class="line">                <span class="comment">// &lt;name, pointer&gt; 加入符号表</span></span><br><span class="line">                IrSymbolTableStack.addSymbolToPeek(identToken.str, alloca);</span><br><span class="line">                <span class="comment">// 有初值 那么进行store</span></span><br><span class="line">                <span class="keyword">if</span>(initValNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                    initValNode.buildIr();</span><br><span class="line">                    IrBuilder.buildStoreInstruction(Irc.synValue ,alloca, Irc.curBlock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 无初值也不必分配 其值未知</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量使用时：</p>
<p>虽然代码有点长（主要是数组处理、常量表达式处理、形参与实参处理搅在一起了），但核心思路比较简单：</p>
<ul>
<li>LVal: 查符号表获得指定局部变量或形参的<code>alloca</code>指针</li>
<li>PrimaryExp: 对于LVal传上来的<code>alloca</code>指针，进行<code>load</code>处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primaryExpNode.java</span></span><br><span class="line">			<span class="comment">// LVal</span></span><br><span class="line">            <span class="comment">// 指针只能从左值中得出</span></span><br><span class="line">            <span class="keyword">if</span>(lValNode != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 正在加载函数参数，且要求指针类型的value，则不进行load</span></span><br><span class="line">                <span class="comment">// 需要消除标记，因为后续还可能再进入primaryExp</span></span><br><span class="line">                <span class="keyword">if</span>(Irc.isBuildingPointerRParam)&#123;</span><br><span class="line">                    Irc.isBuildingPointerRParam = <span class="literal">false</span>;</span><br><span class="line">                    lValNode.buildIr();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 要求int类型的value，此处应该检查load</span></span><br><span class="line">                <span class="comment">// 如果是指针类型 那么进行加载</span></span><br><span class="line">                <span class="comment">// 指针类型在通常状态下的加载，即在此实现</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    lValNode.buildIr();</span><br><span class="line">                    <span class="keyword">if</span>(Irc.synValue.getType() <span class="keyword">instanceof</span> PointerType)&#123;</span><br><span class="line">                        Irc.synValue = IrBuilder.buildLoadInstruction(Irc.synValue, Irc.curBlock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// LValNode.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LVal一般返回指针类型的value，该指针是所求变量的地址。</span></span><br><span class="line"><span class="comment">     * 让上层PrimaryExp来判断是否进行加载</span></span><br><span class="line"><span class="comment">     * 如果isBuildingConstExp，那么一定返回synInt</span></span><br><span class="line"><span class="comment">     * 对于函数实参，其降维操作在此执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@synInt</span>      返回左值的ConstInt值. 前提：isBuildingConstExp.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@synValue</span>    返回存储左值内容的指针（地址）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 查符号表获得左值对应的value</span></span><br><span class="line">        <span class="type">Value</span> <span class="variable">lvalValue</span> <span class="operator">=</span> IrSymbolTableStack.getSymbol(identToken.str);</span><br><span class="line">        <span class="keyword">assert</span> lvalValue != <span class="literal">null</span>;</span><br><span class="line">		... </span><br><span class="line">        <span class="comment">// 左值为Pointer类型 需要进一步取值</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 根据指针指向的类型，进行讨论</span></span><br><span class="line">            <span class="type">ValueType</span> <span class="variable">valueType</span> <span class="operator">=</span> IrTool.getPointingTypeOfPointer(lvalValue);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指向int类型</span></span><br><span class="line">            <span class="keyword">if</span>(valueType <span class="keyword">instanceof</span> IntType)&#123;</span><br><span class="line">                <span class="comment">// 需要直接提取计算出常数 且为全局常量指针 则将计算出的常数使用synInt传递</span></span><br><span class="line">                <span class="keyword">if</span>(Irc.isBuildingConstExp &amp;&amp; lvalValue <span class="keyword">instanceof</span> GlobalVariable)&#123;</span><br><span class="line">                    <span class="type">ConstInt</span> <span class="variable">initValue</span> <span class="operator">=</span> (ConstInt) (((GlobalVariable) lvalValue).getInitValue());</span><br><span class="line">                    Irc.synInt = initValue.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则直接向上传递指针，这一般是变量存储的地址</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Irc.synValue = lvalValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向指针</span></span><br><span class="line">            <span class="comment">// 该pointer一定是当前左值所处函数的 [数组形参]</span></span><br><span class="line">            <span class="comment">// 例如f(int a[], int b[][2])中的 a和b</span></span><br><span class="line">            <span class="comment">// 因此一定不在buildingConstExp</span></span><br><span class="line">            <span class="comment">// lvalValue可能的类型有：</span></span><br><span class="line">            <span class="comment">// 一维数组i32* *</span></span><br><span class="line">            <span class="comment">// 二维数组[2 * i32]* *</span></span><br><span class="line">            <span class="comment">// 因为只有形参在满足SSA的时候 会通过alloca和store 来在本来的指针上多附加一层指针 以存储形参指针的值</span></span><br><span class="line">            <span class="comment">// 返回指针</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(valueType <span class="keyword">instanceof</span> PointerType)&#123;</span><br><span class="line">                <span class="comment">// 取出该指针指向空间的内容</span></span><br><span class="line">                <span class="comment">// 即复原出形参（包括内容和类型）</span></span><br><span class="line">                <span class="comment">// i32*，[2 * i32]*</span></span><br><span class="line">                <span class="type">Value</span> <span class="variable">fParamValue</span> <span class="operator">=</span> IrBuilder.buildLoadInstruction(lvalValue, Irc.curBlock);</span><br><span class="line">                <span class="comment">// 没有[]，则直接原封不动传回，因为这就是形参</span></span><br><span class="line">                <span class="keyword">if</span>(expNodes.isEmpty())&#123;</span><br><span class="line">                    Irc.synValue = fParamValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 一级[]，根据形参本身是一维还是二维，分为两种情况</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(expNodes.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                    expNodes.get(<span class="number">0</span>).buildIr();</span><br><span class="line">                    <span class="type">Value</span> <span class="variable">indexValue</span> <span class="operator">=</span> Irc.synValue;</span><br><span class="line">                    <span class="comment">// 根据index 向前挪动指针的值</span></span><br><span class="line">                    <span class="type">Value</span> <span class="variable">ptrval</span> <span class="operator">=</span> IrBuilder.buildGetElementPtrInstruction(fParamValue, indexValue, Irc.curBlock);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果形参指向的是数组，那么说明形参是二维的。例如int a[][2] =&gt; [2 * i32]*，则形参指向[2* i32]</span></span><br><span class="line">                    <span class="comment">// 但这里只取了一维，也就是说希望传入a[1]</span></span><br><span class="line">                    <span class="comment">// 一定是作为函数的实参！</span></span><br><span class="line">                    <span class="comment">// 那么函数实参传入的类型应当是i32*</span></span><br><span class="line">                    <span class="comment">// 所以应当向下降维</span></span><br><span class="line">                    <span class="keyword">if</span>(IrTool.getPointingTypeOfPointer(fParamValue) <span class="keyword">instanceof</span> ArrayType)&#123;</span><br><span class="line">                        ptrval = IrBuilder.buildRankDownInstruction(ptrval, Irc.curBlock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Irc.synValue = ptrval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 二级[]，只可能是对于二维数组形参int a[][2]的取值，结果应该为int类型</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    expNodes.get(<span class="number">0</span>).buildIr();</span><br><span class="line">                    <span class="type">Value</span> <span class="variable">indexValue1</span> <span class="operator">=</span> Irc.synValue;</span><br><span class="line">                    expNodes.get(<span class="number">1</span>).buildIr();</span><br><span class="line">                    <span class="type">Value</span> <span class="variable">indexValue2</span> <span class="operator">=</span> Irc.synValue;</span><br><span class="line">                    Irc.synValue = IrBuilder.buildGetElementPtrInstruction(fParamValue, indexValue1, indexValue2, Irc.curBlock);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指向数组</span></span><br><span class="line">            <span class="comment">// 则应该为正常的局部数组或者全局数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(valueType <span class="keyword">instanceof</span> ArrayType)&#123;</span><br><span class="line">                <span class="comment">// 常量表达式 最后结果必然是ConstInt</span></span><br><span class="line">                <span class="comment">// 两种情况：全局常量数组 局部常量数组</span></span><br><span class="line">                <span class="comment">// 常量数组都已经存储在了对应的对象内，直接调取方法读取即可</span></span><br><span class="line">                <span class="comment">// 返回synInt</span></span><br><span class="line">                <span class="keyword">if</span>(Irc.isBuildingConstExp)&#123;</span><br><span class="line">                    Constant initVal;</span><br><span class="line">                    <span class="comment">// 全局常量数组 是GlobalVariable形式</span></span><br><span class="line">                    <span class="keyword">if</span>(lvalValue <span class="keyword">instanceof</span> GlobalVariable)&#123;</span><br><span class="line">                        initVal = ((GlobalVariable) lvalValue).getInitValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 局部常量数组 是alloca的形式</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        initVal = ((Alloca) lvalValue).getInitValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 初值数组已经被存储在initVal对象中，根据[]依次获取即可</span></span><br><span class="line">                    <span class="comment">// 此处仍然在buildingConstExp，因此从expNode中获取的是synInt</span></span><br><span class="line">                    <span class="keyword">for</span>(ExpNode expNode : expNodes)&#123;</span><br><span class="line">                        expNode.buildIr();</span><br><span class="line">                        initVal = ((ConstArray) initVal).getElements().get(Irc.synInt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Irc.synInt = ((ConstInt) initVal).getValue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 非常量表达式</span></span><br><span class="line">                <span class="comment">// 这里不再有存储好的初值调用，因此应该使用gep指令</span></span><br><span class="line">                <span class="comment">// 返回指针synValue</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据[]不断使用gep向下取值</span></span><br><span class="line">                    <span class="keyword">for</span>(ExpNode expNode : expNodes)&#123;</span><br><span class="line">                        expNode.buildIr();</span><br><span class="line">                        lvalValue = IrBuilder.buildGetElementPtrInstruction(lvalValue, ConstInt.ZERO(), Irc.synValue, Irc.curBlock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 特别地，需要判断一下int a[2][3] 只调用了 a[0]的情况 : 定是函数实参</span></span><br><span class="line">                    <span class="comment">// 此时result是指向数组的指针</span></span><br><span class="line">                    <span class="comment">// 那么需要进行降维传参</span></span><br><span class="line">                    <span class="keyword">if</span>(IrTool.getPointingTypeOfPointer(lvalValue) <span class="keyword">instanceof</span> ArrayType)&#123;</span><br><span class="line">                        lvalValue = IrBuilder.buildRankDownInstruction(lvalValue, Irc.curBlock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Irc.synValue = lvalValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数形参接收时：</p>
<p>特别地，<strong>函数的形参也类似于局部变量，我们也要将其处理为SSA形式，在栈上分配空间并赋值以代之，否则还是会遇到我们上一节分析出来的问题</strong>！</p>
<ul>
<li>FuncFParamNode：读取形参的类型、名称，创建形参的Value</li>
<li>FuncFParamsNode： 对于每一个形参，都进行<code>alloca</code>，<code>store</code>，其中<code>store</code>的内容就是刚创建的形参的Value。符号表中存入的也是<code>alloca</code>对应的value</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FuncFParamNode.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析参数，并以ValueType的形式传入function，以记录参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIr</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将解析完成的参数类型传给curFunction，在curFunction内部构建参数的value</span></span><br><span class="line">        Irc.curFunction.addArgByValueType(type, Irc.inInt);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// FuncFParamsNode.java</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildIr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;funcFParamNodes.size(); i++)&#123;</span><br><span class="line">            Irc.inInt = i;</span><br><span class="line">            funcFParamNodes.get(i).buildIr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之前已经将参数加入了function对象</span></span><br><span class="line">        <span class="comment">// 使用刚刚解析好的函数参数，来构建SSA形式的参数加载语句</span></span><br><span class="line">        ArrayList&lt;Value&gt; args = Irc.curFunction.getArgValues();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;funcFParamNodes.size(); i++)&#123;</span><br><span class="line">            <span class="type">Value</span> <span class="variable">arg</span> <span class="operator">=</span> args.get(i);</span><br><span class="line">            <span class="type">Alloca</span> <span class="variable">alloca</span> <span class="operator">=</span> IrBuilder.buildAllocaInstruction(arg.getType(), Irc.curBlock);</span><br><span class="line">            IrBuilder.buildStoreInstruction(arg, alloca, Irc.curBlock);</span><br><span class="line">            <span class="comment">// 在符号表中记录形参，其对应value为alloca，之后调用的时候要load</span></span><br><span class="line">       	IrSymbolTableStack.addSymbolToPeek(funcFParamNodes.get(i).getIdentToken().str, alloca);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-5-GEP指令的使用"><a href="#6-5-GEP指令的使用" class="headerlink" title="6.5 GEP指令的使用"></a>6.5 GEP指令的使用</h4><p>例如现在需要翻译如下数组定义语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">10</span>, <span class="number">20</span>&#125;, &#123;<span class="number">30</span>, <span class="number">40</span>&#125;, &#123;<span class="number">50</span>, <span class="number">60</span>&#125;&#125;;	<span class="comment">// 全局数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>局部变量的分配是在栈上进行的，需要我们手动分配内存</strong>。</p>
<p>可以写出如下llvm语句，来分配（alloca）出这么大的空间。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%instr1</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">3</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>alloca指令会在指定类型上，套一层指针</strong>，例如此时instr1的类型是**[3 x [2 x i32]]***</p>
<p>**符号表中存储的是&lt;局部变量名, 存储局部变量值的指针(即alloca类型的Value类)&gt;**。</p>
<p>接下来，我们需要向分配好的地址中存储常数。</p>
<p>要使用<code>store</code>指令给每一个元素赋值，我们就需要获取每一个元素具体地址的指针。</p>
<p>这样，我们就需要用到求地址指令<code>getelementptr</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%instr2 = getelementptr [3 x [2 x i32]], [3 x [2 x i32]]* %instr1, i32 0, i32 0</span><br><span class="line">%instr3 = getelementptr [2 x i32], [2 x i32]* %instr2, i32 0, i32 0</span><br><span class="line">store i32 10, i32* %instr3</span><br><span class="line">%instr5 = getelementptr i32, i32* %instr3, i32 1</span><br><span class="line">store i32 20, i32* %instr5</span><br><span class="line">%instr7 = getelementptr i32, i32* %instr3, i32 2</span><br><span class="line">store i32 30, i32* %instr7</span><br><span class="line">%instr9 = getelementptr i32, i32* %instr3, i32 3</span><br><span class="line">store i32 40, i32* %instr9</span><br><span class="line">%instr11 = getelementptr i32, i32* %instr3, i32 4</span><br><span class="line">store i32 50, i32* %instr11</span><br><span class="line">%instr13 = getelementptr i32, i32* %instr3, i32 5</span><br><span class="line">store i32 60, i32* %instr13</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getelementptr求地址指令：</p>
<p>这个指令可以带一个偏移，或者两个偏移。</p>
<p>记getelementptr(a, op1)为：对基地址指针a，使用gep指令，带一个操作数（偏移）op1。</p>
<p>记getelementptr(a, op1, op2)为：对基地址指针a，使用gep指令，带两个操作数（偏移）op1, op2。[要求a一定是指向数组的指针]</p>
<p>结论为：</p>
<ul>
<li>$getelementptr(a, op1) &#x3D; a + op1 * sizeof(a)$，返回指针类型与a相同。</li>
<li>$getelementptr(a, op1) &#x3D; a + op1 * sizeof(a) + op2 * sizeof(a指向的数组的元素) $【例如如果a指向<code>a[2][3]</code>，那么这里<code>sizeof(a指向的数组的元素)</code>就是a[0]或者a[1]的大小】，返回指针类型是a“降了一维”后的类型。</li>
</ul>
<p>以<code>int a[2][3]</code>为例（上面代码中的例子是<code>int a[3][2]</code>），假设a基地址0，容易计算出二维数组a大小为$4<em>2</em>3 &#x3D; 24$，一维数组a[0]大小为$3*4&#x3D;12$。现举例如下：</p>
<ul>
<li>getelementptr(a, 0)会返回什么？</li>
</ul>
<p>会返回0 *24 &#x3D; 0，即a的地址。</p>
<p>其类型是<code>[2 x [3 x i32]]*</code>（即与a的类型相同）。</p>
<ul>
<li>getelementptr(a, 1)会返回什么？</li>
</ul>
<p>会返回1 * 24 &#x3D; 1，即飞出去一整个a之后的地址，完全不在a数组之内。</p>
<p>其类型是<code>[2 x [3 x i32]]*</code>（即与a的类型相同）。</p>
<ul>
<li>getelementptr(a, 0, 0)会返回什么？</li>
</ul>
<p>会返回0*24 + 0 * 12 &#x3D; 0 ，即a[0]的地址。其类型是<code>[3 x i32]*</code>（即脱掉了最外层的[]，但是地址的值不变。因此该指令经常用来转变一个指针的类型）</p>
<ul>
<li>getelementptr(a, 0, 1)会返回什么？</li>
</ul>
<p>会返回0*24 + 1 * 12 &#x3D; 12，即a[1]的地址。</p>
<p>其类型是<code>[3 x i32]*</code>。</p>
<ul>
<li>getelementptr(a, 666, 233)会返回什么？</li>
</ul>
<p>会返回666*24 + 233 * 12，即直接飞出了666个a，再飞出去233个a[0]那么大。</p>
<p>其类型是<code>[3 x i32]*</code>。</p>
</blockquote>
<p>再回头看我们的代码。</p>
<p>下面这两条指令是在把<code>[2 x [3 x i32]]*</code>转变为<code>i32*</code>类型，因为我们要向数组元素内存入常数，而数组元素是int类型的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%instr2 = getelementptr [3 x [2 x i32]], [3 x [2 x i32]]* %instr1, i32 0, i32 0</span><br><span class="line">%instr3 = getelementptr [2 x i32], [2 x i32]* %instr2, i32 0, i32 0</span><br></pre></td></tr></table></figure>

<p>之后就是不断地移动指针，然后在该地址内存入常数。例如这里是向第6个元素（即<code>a[2][3]</code>中存储元素）。可以看到，初始化元素时需要展平数组。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%instr13</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%instr3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">60</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%instr13</span></span><br></pre></td></tr></table></figure>

<p>部分Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node/VarDefNode.java</span></span><br><span class="line"><span class="comment">// VarDef → Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; | Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; &#x27;=&#x27; InitVal</span></span><br><span class="line">            <span class="comment">// 局部数组变量</span></span><br><span class="line">            <span class="comment">// 解析维数信息</span></span><br><span class="line">            ArrayList&lt;Integer&gt; dims = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(ConstExpNode constExpNode : constExpNodes)&#123;</span><br><span class="line">                constExpNode.buildIr();</span><br><span class="line">                dims.add(Irc.synInt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ArrayType</span> <span class="variable">arrayType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayType</span>(<span class="keyword">new</span> <span class="title class_">IntType</span>(<span class="number">32</span>), dims);</span><br><span class="line">                <span class="comment">// 分配空间</span></span><br><span class="line">                <span class="type">Alloca</span> <span class="variable">arrayPointer</span> <span class="operator">=</span> IrBuilder.buildAllocaInstruction(arrayType, Irc.curBlock);</span><br><span class="line">                <span class="comment">// 加入符号表</span></span><br><span class="line">                IrSymbolTableStack.addSymbolToPeek(identToken.str, arrayPointer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 有初始值</span></span><br><span class="line">                <span class="comment">// 处理类似于局部常量数组</span></span><br><span class="line">                <span class="comment">// FlattenArray通过syvValueArray传递上来</span></span><br><span class="line">                <span class="keyword">if</span>(initValNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                    initValNode.setDims(dims);</span><br><span class="line">                    <span class="comment">// 解析初始化值，通过Irc.synValueArray传上来</span></span><br><span class="line">                    initValNode.buildIr();</span><br><span class="line">                    <span class="comment">// 使用store和gep将展平后的内容数组存入数组</span></span><br><span class="line">                    IrBuilder.buildStoreWithValuesIntoArray(arrayPointer, dims, Irc.synValueArray, Irc.curBlock);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 无初始值，不予处理</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建GEP和store指令，将指定的flatten value array，存入局部数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrayPointer  目标数组指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dims          数组维数信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flattenArray  要存的value内容数组（展平）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildStoreWithValuesIntoArray</span><span class="params">(Alloca arrayPointer, ArrayList&lt;Integer&gt; dims, ArrayList&lt;Value&gt; flattenArray, BasicBlock parent)</span>&#123;</span><br><span class="line">        <span class="comment">// 接下来获取一个指向底层元素的指针，挨个存入元素</span></span><br><span class="line">        <span class="type">GetElementPtr</span> <span class="variable">basePtr</span> <span class="operator">=</span> IrBuilder.buildRankDownInstruction(arrayPointer, parent);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;dims.size(); i++)&#123;</span><br><span class="line">            basePtr = IrBuilder.buildRankDownInstruction(basePtr, parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历展平之后的数组</span></span><br><span class="line">        <span class="comment">// 依次将数组内的元素使用store进行存储，存储位置为base + i</span></span><br><span class="line">        <span class="type">GetElementPtr</span> <span class="variable">elementPtr</span> <span class="operator">=</span> basePtr;</span><br><span class="line">        IrBuilder.buildStoreInstruction(flattenArray.get(<span class="number">0</span>), elementPtr, parent);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt; flattenArray.size(); i++)&#123;</span><br><span class="line">            <span class="comment">// p = base + i</span></span><br><span class="line">            elementPtr = IrBuilder.buildGetElementPtrInstruction(basePtr, <span class="keyword">new</span> <span class="title class_">ConstInt</span>(<span class="number">32</span>, i), parent);</span><br><span class="line">            IrBuilder.buildStoreInstruction(flattenArray.get(i), elementPtr, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-ConstExp的处理与常量传播"><a href="#6-6-ConstExp的处理与常量传播" class="headerlink" title="6.6 ConstExp的处理与常量传播"></a>6.6 ConstExp的处理与常量传播</h4><p>在我们的文法当中，有这样的声明：</p>
<blockquote>
<p>常量表达式 ConstExp </p>
<p>ConstExp -&gt; AddExp 中使用的 ident 必须是常量</p>
</blockquote>
<p>何为常量？即能够在编译阶段就确定值的量，包括了常量标识符与立即数。<strong>对于常量，我们可以在编译阶段就计算出常量表达式的值，以及将常量标识符替换为其值</strong>。</p>
<p>为此，我们在<code>Irc</code>里设置有字段，在<code>Exp</code>系的<code>buildIr</code>内，构建常量时的分类讨论的方式有所不同，且由于能够计算出int类型具体值，我们只需要进行<code>synInt</code>综合属性的传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前是否正在计算 无变量常数表达式</span></span><br><span class="line"><span class="comment">     * 如果是，那么综合属性只需要传递syvInt，且计算情况有所减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isBuildingConstExp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>常量分为数组常量和非数组常量，其行为有所不同：</p>
<table>
<thead>
<tr>
<th></th>
<th>int常量</th>
<th>数组常量</th>
</tr>
</thead>
<tbody><tr>
<td>是否在llvm代码中显式声明</td>
<td>否</td>
<td>与普通数组变量一致，采用alloca,store</td>
</tr>
<tr>
<td>在<code>ConstExp</code>下</td>
<td>直接求出int值</td>
<td>直接求出指定元素的int值</td>
</tr>
<tr>
<td>非<code>ConstExp</code>下</td>
<td>直接求出int值</td>
<td>与普通数组变量一致，采用gep，load</td>
</tr>
</tbody></table>
<p>给出如下例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b[a[<span class="number">1</span>]] = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>,a[c],b[<span class="number">1</span>],c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@a</span> <span class="operator">=</span> dso_local <span class="keyword">constant</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@getint</span>()</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putstr</span>(<span class="type">i8</span>*)</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putch</span>(<span class="type">i32</span>)</span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">b<span class="number">0</span>:</span><br><span class="line">	<span class="variable">%i1</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">20</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">	<span class="variable">%i2</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">20</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">20</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%i1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">store</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%i2</span></span><br><span class="line">	<span class="variable">%i4</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%i2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">store</span> <span class="type">i32</span> <span class="number">4</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%i4</span></span><br><span class="line">	<span class="variable">%i6</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="title">@a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">	<span class="variable">%i7</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%i6</span></span><br><span class="line">	<span class="variable">%i8</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">20</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">20</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%i1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">	<span class="variable">%i9</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%i8</span></span><br><span class="line">	<span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%i7</span>)</span><br><span class="line">	<span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%i9</span>)</span><br><span class="line">	<span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-7-符号表的构建"><a href="#6-7-符号表的构建" class="headerlink" title="6.7 符号表的构建"></a>6.7 符号表的构建</h4><p>类似错误处理，又重新搭了一遍栈式符号表。</p>
<h4 id="6-8-其他"><a href="#6-8-其他" class="headerlink" title="6.8 其他"></a>6.8 其他</h4><p>其他关键的设计还有跳转关系的构建（短路求值+for循环的实现)、函数形参的处理、变量类型（<code>ir/type</code>包）</p>
<p>还有3h就得交文档了，优化文档还没写，因此其余部分具体逻辑详见代码，代码中有详细注释。急急急。</p>
<h2 id="7-目标代码生成与优化"><a href="#7-目标代码生成与优化" class="headerlink" title="7. 目标代码生成与优化"></a>7. 目标代码生成与优化</h2><p>任务是以此前生成的中间代码（树形结构表示的<code>llvm</code>)作为输入，输出与源程序语义等价的<code>mips</code>代码。 </p>
<p>在llvm中，<strong>我们已经将源代码转换成了很接近中间代码的形式了：我们划分并生成了基本块，生成了几乎能一等一转化为mips的llvm指令</strong>。因此在目标代码的<strong>初步</strong>生成的过程中，我们的关注点主要在于<strong>存储管理、指令的等价翻译</strong>。</p>
<h4 id="7-1-架构设计"><a href="#7-1-架构设计" class="headerlink" title="7.1 架构设计"></a>7.1 架构设计</h4><p>后端的流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 生成带有虚拟寄存器的目标代码</span></span><br><span class="line">       irModule.buildMips();</span><br><span class="line">       <span class="comment">// 寄存器分配</span></span><br><span class="line">       <span class="keyword">if</span>(Config.openRegAllocOpt)&#123;</span><br><span class="line">           <span class="type">RegBuilder</span> <span class="variable">regBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegBuilder</span>();</span><br><span class="line">           regBuilder.buildRegs();</span><br><span class="line">           <span class="comment">// 窥孔优化</span></span><br><span class="line">           <span class="keyword">if</span>(Config.openPeepHoleOpt)&#123;</span><br><span class="line">               <span class="type">Peephole</span> <span class="variable">peephole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Peephole</span>();</span><br><span class="line">               peephole.doPeephole();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与目标代码生成有关的项目文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">├── ir			// 中间代码生成与优化</span><br><span class="line">|   ├── analyze				// 中间代码优化</span><br><span class="line">|   ├── types				// value的类型</span><br><span class="line">|   ├── values				// values</span><br><span class="line">|   |	└── constants				// Constant value们</span><br><span class="line">|   │   └── instructions			// Instruction value们</span><br><span class="line">|   |	└── BasicBlock.java			</span><br><span class="line">|   |	└── Function.java			</span><br><span class="line">|   |	└── GlobalVariable.java	</span><br><span class="line">|   |	└── Module.java	</span><br><span class="line">|   |	└── Value.java	</span><br><span class="line">|   |	└── User.java		</span><br><span class="line">|   ├── Irc.java					// 在中间代码生成中保存上下文信息</span><br><span class="line">│   ├── Irbuilder.java				// 中间代码的入口类及工厂类</span><br><span class="line">├── backend		// Mips生成与优化 </span><br><span class="line">|   ├── instructions		// Instruction们</span><br><span class="line">|   ├── operands			// 操作数们，包括立即数，虚拟、物理寄存器，标签</span><br><span class="line">|   ├── opt					// 目标代码优化</span><br><span class="line">|   |	└── BlockliveVarInfo.java	// 活跃变量分析</span><br><span class="line">|   │   └── RegBuilder.java			// 图着色寄存器分配</span><br><span class="line">|   |	└── Peephole.java			// 窥孔优化</span><br><span class="line">|   ├── Mc.java						// 在目标代码生成中保存上下文信息</span><br><span class="line">|   └── MipsBuilder.java			// 目标代码的入口及指令的工厂类</span><br></pre></td></tr></table></figure>

<h5 id="7-1-1-MipsBuilder：指令的工厂类"><a href="#7-1-1-MipsBuilder：指令的工厂类" class="headerlink" title="7.1.1 MipsBuilder：指令的工厂类"></a>7.1.1 MipsBuilder：指令的工厂类</h5><p>在MipsBuilder中封装有构建各种指令、构建操作数的工厂模式方法。</p>
<p>例如构建一条move指令并加入指定的<code>MipsBlock</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MipsBuilder.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建move指令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MipsMove <span class="title function_">buildMove</span><span class="params">(MipsOperand dst, MipsOperand src, BasicBlock irBlock)</span>&#123;</span><br><span class="line">        <span class="type">MipsMove</span> <span class="variable">move</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MipsMove</span>(dst, src);</span><br><span class="line">        Mc.b(irBlock).addInstruction(move);</span><br><span class="line">        <span class="keyword">return</span> move;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Add.java</span></span><br><span class="line">		<span class="comment">// op1 op2均为常数 则加法可以直接变为move dst Imm(op1+op2)</span></span><br><span class="line">        <span class="keyword">if</span> (op1 <span class="keyword">instanceof</span> ConstInt &amp;&amp; op2 <span class="keyword">instanceof</span> ConstInt) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">imm1</span> <span class="operator">=</span> IrTool.getValueOfConstInt(op1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">imm2</span> <span class="operator">=</span> IrTool.getValueOfConstInt(op2);</span><br><span class="line">            MipsBuilder.buildMove(dst, <span class="keyword">new</span> <span class="title class_">MipsImm</span>(imm1 + imm2), getParent());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-1-2-Mc：记录llvm成分到mips成分的映射"><a href="#7-1-2-Mc：记录llvm成分到mips成分的映射" class="headerlink" title="7.1.2 Mc：记录llvm成分到mips成分的映射"></a>7.1.2 Mc：记录<code>llvm</code>成分到<code>mips</code>成分的映射</h5><p>我们是在llvm的成分类中进行的mips生成，因此需要将llvm成分与mips成分进行映射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ir函数对象 对应的 mips函数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> irFunction    ir函数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>              mips函数对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MipsFunction <span class="title function_">f</span><span class="params">(Function irFunction)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> functionMap.get(irFunction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ir基本块对象 对应的 mips基本块对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> irBlock   ir基本块对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          mips基本块对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MipsBlock <span class="title function_">b</span><span class="params">(BasicBlock irBlock)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blockMap.get(irBlock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取ir Value对象 对应的 mipsOperand对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> irValue   ir Value对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          mipsOperand对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MipsOperand <span class="title function_">op</span><span class="params">(Value irValue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> opMap.get(irValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询在mipsBlock内，op1/op2 是否已有计算结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          计算结果的mipsOperand对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MipsOperand <span class="title function_">div</span><span class="params">(MipsBlock mipsBlock, MipsOperand op1, MipsOperand op2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divMap.get(<span class="keyword">new</span> <span class="title class_">Triple</span>&lt;&gt;(mipsBlock, op1, op2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-1-3-llvm的成分类：mips生成的主要场所"><a href="#7-1-3-llvm的成分类：mips生成的主要场所" class="headerlink" title="7.1.3 llvm的成分类：mips生成的主要场所"></a>7.1.3 <code>llvm</code>的成分类：mips生成的主要场所</h5><p>通过遍历<code>llvm</code>的树形结构来生成<code>mips</code>，遍历在<code>ir/values</code>下的各个value类进行，他们都实现了父类<code>Value</code>的<code>buildMips()</code>方法。</p>
<h5 id="7-1-4-backend-instructions-Mips指令类"><a href="#7-1-4-backend-instructions-Mips指令类" class="headerlink" title="7.1.4 backend/instructions: Mips指令类"></a>7.1.4 <code>backend/instructions</code>: Mips指令类</h5><p>指令类都继承了<code>MipsInstruction</code>类，<strong>该类内有<code>src</code>操作数和<code>dst</code>操作数的相应管理方法，包括<code>use</code>，<code>def</code>的记录，用于后续寄存器分配时，对虚拟寄存器进行查询、替换</strong>。</p>
<h5 id="7-1-5-backend-operands-操作数类"><a href="#7-1-5-backend-operands-操作数类" class="headerlink" title="7.1.5 backend/operands: 操作数类"></a>7.1.5 <code>backend/operands</code>: 操作数类</h5><p>该包内的类均可以作为<code>mips</code>指令的操作数，具体来说有立即数、虚拟寄存器、物理寄存器、标签。</p>
<p>物理寄存器的相关配置在<code>RegType</code>枚举类中，记录了物理寄存器的编号、名称、何者需要在函数调用时保存、何者能够作为全局寄存器分配等信息。</p>
<h4 id="7-2-构建流程"><a href="#7-2-构建流程" class="headerlink" title="7.2 构建流程"></a>7.2 构建流程</h4><p>带有虚拟寄存器的mips的总体构建流程如下：</p>
<h5 id="7-2-1-构建-data段"><a href="#7-2-1-构建-data段" class="headerlink" title="7.2.1 构建.data段"></a>7.2.1 构建.data段</h5><p>构建.data段主要是在翻译<code>llvm</code>的全局变量元素<code>GlobalVariable</code>。</p>
<p>先前在<code>llvm</code>生成过程中，我们将需要<code>printf</code>输出的字符串重新分配为了全局常量字符串，因此这里全局变量共有三类：字符串、int变量、int数组。依次构建<code>mipsGlobalVariable</code>，然后加入<code>MipsModule</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GlobalVariable.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMips</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MipsGlobalVariable</span> <span class="variable">mipsGlobalVariable</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 未初始化的int数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(initValue <span class="keyword">instanceof</span> ZeroInitializer)&#123;</span><br><span class="line">            mipsGlobalVariable = <span class="keyword">new</span> <span class="title class_">MipsGlobalVariable</span>(getName(), initValue.getType().getSize());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 常量字符串</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(initValue <span class="keyword">instanceof</span> ConstString)&#123;</span><br><span class="line">            mipsGlobalVariable = <span class="keyword">new</span> <span class="title class_">MipsGlobalVariable</span>(getName(), ((ConstString) initValue).getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int变量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(initValue <span class="keyword">instanceof</span> ConstInt)&#123;</span><br><span class="line">            mipsGlobalVariable = <span class="keyword">new</span> <span class="title class_">MipsGlobalVariable</span>(getName(), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">                add(((ConstInt) initValue).getValue());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(initValue <span class="keyword">instanceof</span> ConstArray)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; ints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Constant element : ((ConstArray) initValue).getFlattenElements())&#123;</span><br><span class="line">                ints.add(((ConstInt) element).getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            mipsGlobalVariable = <span class="keyword">new</span> <span class="title class_">MipsGlobalVariable</span>(getName(), ints);</span><br><span class="line">        &#125;</span><br><span class="line">        MipsModule.addGlobalVariable(mipsGlobalVariable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2-2-为所有Block和Function创建Mips对象，并映射到llvm的相应对象"><a href="#7-2-2-为所有Block和Function创建Mips对象，并映射到llvm的相应对象" class="headerlink" title="7.2.2 为所有Block和Function创建Mips对象，并映射到llvm的相应对象"></a>7.2.2 为所有Block和Function创建Mips对象，并映射到llvm的相应对象</h5><p>没有太多可说的，作用主要是方便在后续遍历语句时，能够方便地引用函数和基本块（用于call、br等llvm指令的翻译）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将中间代码的函数和基本块对象:</span></span><br><span class="line"><span class="comment">     * 1.构建mips里的相应对象</span></span><br><span class="line"><span class="comment">     * 2.加入Module</span></span><br><span class="line"><span class="comment">     * 3.信息存储到mips对象里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapFunctionBlockIrToMips</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有函数</span></span><br><span class="line">        <span class="keyword">for</span> (Function irFunction : functions)&#123;</span><br><span class="line">            <span class="comment">// 构建函数对象</span></span><br><span class="line">            <span class="type">MipsFunction</span> <span class="variable">mipsFunction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MipsFunction</span>(irFunction.getName(), irFunction.isLibFunc());</span><br><span class="line">            Mc.addFunctionMapping(irFunction, mipsFunction);</span><br><span class="line">            MipsModule.addFunction(mipsFunction);</span><br><span class="line">            <span class="comment">// 构建基本块对象</span></span><br><span class="line">            ArrayList&lt;BasicBlock&gt; blocks = irFunction.getBasicBlocks();</span><br><span class="line">            <span class="keyword">for</span> (BasicBlock irBlock : blocks)&#123;</span><br><span class="line">                <span class="type">MipsBlock</span> <span class="variable">mipsBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MipsBlock</span>(irBlock.getName(), irBlock.getLoopDepth());</span><br><span class="line">                Mc.addBlockMapping(irBlock, mipsBlock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录mipsBlock的前驱块信息, 前驱块当然也是mipsBlock</span></span><br><span class="line">            <span class="keyword">for</span> (BasicBlock irBlock : blocks)&#123;</span><br><span class="line">                <span class="type">MipsBlock</span> <span class="variable">mipsBlock</span> <span class="operator">=</span> Mc.b(irBlock);</span><br><span class="line">                <span class="keyword">for</span>(BasicBlock irPreBlock : irBlock.getPreBlocks())&#123;</span><br><span class="line">                    mipsBlock.addPreBlock(Mc.b(irPreBlock));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2-3-遍历llvm的树形结构"><a href="#7-2-3-遍历llvm的树形结构" class="headerlink" title="7.2.3 遍历llvm的树形结构"></a>7.2.3 遍历<code>llvm</code>的树形结构</h5><p>依序遍历<code>llvm</code>的所有函数、所有基本块、所有指令，进行翻译。</p>
<h4 id="7-3-存储管理的翻译"><a href="#7-3-存储管理的翻译" class="headerlink" title="7.3 存储管理的翻译"></a>7.3 存储管理的翻译</h4><p>在<code>llvm</code>到<code>mips</code>的翻译过程中，与原指令或llvm成分长相完全不同的Mips成分，当属存储管理。具体点来说，是函数调用与返回的存储管理。</p>
<h5 id="7-3-1-Call：参数传递"><a href="#7-3-1-Call：参数传递" class="headerlink" title="7.3.1 Call：参数传递"></a>7.3.1 Call：参数传递</h5><p>Call的作用是调用函数，理所当然地，在mips中需要我们手动进行实参的传递，同时记录<code>MipsCall</code>指令对于寄存器的修改（即def）。</p>
<p>对于前四个参数，保存在<code>a0</code>-<code>a3</code>里即可。对于更多的参数，需要保存在栈上。</p>
<p>调用函数在调用者处的准备工作，都由Call进行翻译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMips</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MipsBlock</span> <span class="variable">mipsBlock</span> <span class="operator">=</span> Mc.b(getParent());</span><br><span class="line">        <span class="type">MipsFunction</span> <span class="variable">mipsFunction</span> <span class="operator">=</span> Mc.f(function);</span><br><span class="line">        <span class="comment">// 先构建出call指令，后续要记录该指令用到的A寄存器</span></span><br><span class="line">        <span class="comment">// ！这也是唯一一次使用野生未封装的new MipsInstruction</span></span><br><span class="line">        MipsInstruction call;</span><br><span class="line">        <span class="comment">// 内建函数，需要宏调用</span></span><br><span class="line">        <span class="keyword">if</span> (function.isLibFunc()) &#123;</span><br><span class="line">            call = <span class="keyword">new</span> <span class="title class_">MipsMacro</span>(mipsFunction.getName());</span><br><span class="line">            <span class="comment">// 系统调用必然改变 v0, v0加入def</span></span><br><span class="line">            call.addDefReg(MipsRealReg.V0); <span class="comment">// <span class="doctag">TODO:</span> addDefReg 双参数修改为单参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非内建函数，直接构建jal指令即可</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            call = <span class="keyword">new</span> <span class="title class_">MipsCall</span>(mipsFunction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行传参, 遍历所有irValue参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">argc</span> <span class="operator">=</span> getArgs().size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="type">Value</span> <span class="variable">irArg</span> <span class="operator">=</span> getArgs().get(i);</span><br><span class="line">            MipsOperand src;</span><br><span class="line">            <span class="comment">// 前四个参数存储在a0-3内</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                src = MipsBuilder.buildOperand(irArg, <span class="literal">true</span>, Mc.curIrFunction, getParent());</span><br><span class="line">                <span class="type">MipsMove</span> <span class="variable">move</span> <span class="operator">=</span> MipsBuilder.buildMove(<span class="keyword">new</span> <span class="title class_">MipsRealReg</span>(<span class="string">&quot;a&quot;</span> + i), src, getParent());</span><br><span class="line">                <span class="comment">// 加入use，保护寄存器分配时不消除move</span></span><br><span class="line">                call.addUseReg(move.getDst());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后面的参数先存进寄存器里，再store进内存</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 要求存入寄存器</span></span><br><span class="line">                src = MipsBuilder.buildOperand(irArg, <span class="literal">false</span>, Mc.curIrFunction, getParent());</span><br><span class="line">                <span class="comment">// 存入 SP - 4 * nowNum 处</span></span><br><span class="line">                <span class="type">MipsImm</span> <span class="variable">offsetOperand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MipsImm</span>(-(argc - i) * <span class="number">4</span>);</span><br><span class="line">                MipsBuilder.buildStore(src, MipsRealReg.SP, offsetOperand, getParent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈的生长</span></span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// 向下生长4 * allNum: SP = SP - 4 * allNum</span></span><br><span class="line">            <span class="type">MipsOperand</span> <span class="variable">offsetOperand</span> <span class="operator">=</span> MipsBuilder.buildImmOperand(<span class="number">4</span> * (argc - <span class="number">4</span>), <span class="literal">true</span>, Mc.curIrFunction, getParent());</span><br><span class="line">            MipsBuilder.buildBinary(MipsBinary.BinaryType.SUBU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数准备妥当后，再执行jal指令</span></span><br><span class="line">        mipsBlock.addInstruction(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这条语句执行完成的场合，恰是从函数中返回</span></span><br><span class="line">        <span class="comment">// 栈的恢复 与生长相反，做加法即可</span></span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">MipsOperand</span> <span class="variable">offsetOperand</span> <span class="operator">=</span> MipsBuilder.buildImmOperand(<span class="number">4</span> * (argc - <span class="number">4</span>), <span class="literal">true</span>, Mc.curIrFunction, getParent());</span><br><span class="line">            MipsBuilder.buildBinary(MipsBinary.BinaryType.ADDU, MipsRealReg.SP, MipsRealReg.SP, offsetOperand, getParent());</span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-2-MipsFunction：保存现场"><a href="#7-3-2-MipsFunction：保存现场" class="headerlink" title="7.3.2 MipsFunction：保存现场"></a>7.3.2 MipsFunction：保存现场</h5><p>MipsFunction是Mips函数对象。</p>
<p>在与Call的关系中，MipsFunction是被调用的一方，由MipsFunction负责保存现场。</p>
<p>如下方法能够记录在本函数内有改动（def）的寄存器，同时计算栈帧大小。这些寄存器在返回调用者后可能有改变，需要保存在栈帧内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈上的空间从上到下依次为：</span></span><br><span class="line"><span class="comment">     * 1.调用者保存的寄存器</span></span><br><span class="line"><span class="comment">     * 2.其他alloca</span></span><br><span class="line"><span class="comment">     * 3.参数alloca</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rebuildStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历下属所有语句，记录所有用过的寄存器，作为函数调用前要保存的现场</span></span><br><span class="line">        <span class="keyword">for</span> (MipsBlock block : blocks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MipsInstruction instruction : block.getInstructions()) &#123;</span><br><span class="line">                <span class="comment">// 保存写过的寄存器(的类型)</span></span><br><span class="line">                <span class="keyword">for</span> (MipsOperand defReg : instruction.getDefRegs()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (defReg <span class="keyword">instanceof</span> MipsRealReg) &#123;</span><br><span class="line">                        <span class="type">RegType</span> <span class="variable">regType</span> <span class="operator">=</span> ((MipsRealReg) defReg).getType();</span><br><span class="line">                        <span class="keyword">if</span> (RegType.regsNeedSaving.contains(regType)) &#123;</span><br><span class="line">                            regsNeedSaving.add(regType);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;[MipsFunction] defReg中混入了非物理寄存器！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要分配的用于保存现场的空间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stackRegSize</span> <span class="operator">=</span> <span class="number">4</span> * regsNeedSaving.size();</span><br><span class="line">        <span class="comment">// 总的空间大小：alloca空间 + 保存现场的空间</span></span><br><span class="line">        totalStackSize = stackRegSize + allocaSize;</span><br><span class="line">        <span class="comment">// 更新先前记录的 保存在栈上的参数 的位移</span></span><br><span class="line">        <span class="keyword">for</span> (MipsImm argOffset : argOffsets) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newOffset</span> <span class="operator">=</span> argOffset.getValue() + totalStackSize;</span><br><span class="line">            argOffset.setValue(newOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>保存现场的具体代码则直接放在了<code>MipsFunction</code>的打印处，实际上没有加入指令序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要打印：</span></span><br><span class="line"><span class="comment">     * 函数 label</span></span><br><span class="line"><span class="comment">     * 保存被调用者寄存器</span></span><br><span class="line"><span class="comment">     * 移动栈指针 sp</span></span><br><span class="line"><span class="comment">     * 基本块的mips代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLibFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(name).append(<span class="string">&quot;:\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 非主函数需要保存寄存器</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 保存现场</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stackOffset</span> <span class="operator">=</span> -<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (RegType regType : regsNeedSaving) &#123;</span><br><span class="line">                <span class="comment">// 保存位置：-stackOffset($SP)</span></span><br><span class="line">                sb.append(<span class="string">&quot;\t&quot;</span>).append(<span class="string">&quot;sw\t&quot;</span>).append(regType).append(<span class="string">&quot;,\t&quot;</span>)</span><br><span class="line">                        .append(stackOffset).append(<span class="string">&quot;($sp)\n&quot;</span>);</span><br><span class="line">                <span class="comment">// 继续向下生长</span></span><br><span class="line">                stackOffset -= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// $SP = $SP - totalStackSize</span></span><br><span class="line">        <span class="keyword">if</span> (totalStackSize != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;\tadd\t$sp,\t$sp,\t&quot;</span>).append(-totalStackSize).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成基本块的mips</span></span><br><span class="line">        <span class="keyword">for</span> (MipsBlock block : blocks) &#123;</span><br><span class="line">            sb.append(block);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-3-3-MipsRet：恢复现场"><a href="#7-3-3-MipsRet：恢复现场" class="headerlink" title="7.3.3 MipsRet：恢复现场"></a>7.3.3 MipsRet：恢复现场</h5><p>MipsRet是Mips的返回指令对象，由llvm的Ret指令直接翻译而来。</p>
<p>Ret对象会记录其所属的MipsFunction，以方便地取用寄存器的保存信息。</p>
<p>同样地，恢复现场的具体代码则直接放在了<code>MipsRet</code>的打印处，实际上没有加入指令序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">stackSize</span> <span class="operator">=</span> function.getTotalStackSize();</span><br><span class="line">        <span class="comment">// 返回前将SP复位</span></span><br><span class="line">        <span class="keyword">if</span> (stackSize != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;add\t$sp, \t$sp,\t&quot;</span>).append(stackSize).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主函数直接结束运行</span></span><br><span class="line">        <span class="keyword">if</span> (function.getName().equals(<span class="string">&quot;main&quot;</span>)) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;\tli\t$v0,\t10\n&quot;</span>);</span><br><span class="line">            sb.append(<span class="string">&quot;\tsyscall\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非主函数，需要恢复现场</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在返回之前回复寄存器寄存器</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">stackOffset</span> <span class="operator">=</span> -<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (RegType regType : function.getRegsNeedSaving()) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;\t&quot;</span>).append(<span class="string">&quot;lw\t&quot;</span>).append(regType).append(<span class="string">&quot;,\t&quot;</span>).append(stackOffset).append(<span class="string">&quot;($sp)\n&quot;</span>);</span><br><span class="line">                stackOffset -= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳转返回</span></span><br><span class="line">            sb.append(<span class="string">&quot;\tjr\t$ra\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">H1kari</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/20/compiler-report/">http://example.com/2023/12/20/compiler-report/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">H1kari's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/28/dl-bugs-1/" title="关于Conda在install时爆出段错误的解决办法"><img class="cover" src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于Conda在install时爆出段错误的解决办法</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/20/compiler-opt-report/" title="BUAA2023秋编译原理 优化文档"><img class="cover" src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA2023秋编译原理 优化文档</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">H1kari</div><div class="author-info__description">点击下载原神>></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">侵刪.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%96%87%E6%A1%A3"><span class="toc-number">1.</span> <span class="toc-text">编译文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8F%82%E8%80%83%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1. 参考编译器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">1.1 总体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">1.2 文件组织与接口设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">1.1.0.2.1.</span> <span class="toc-text">1.2.1 文件组织</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2. 编译器总体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">2.1 总体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">2.2 文件组织与接口设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">2.2.1 文件组织</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%A5%E5%8F%A3"><span class="toc-number">1.2.0.2.2.</span> <span class="toc-text">2.2.2 编译器入口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-%E5%8F%82%E6%95%B0%E8%AE%BE%E5%AE%9A"><span class="toc-number">1.2.0.2.3.</span> <span class="toc-text">2.2.3 参数设定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-4-%E5%90%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E5%85%A5%E5%8F%A3"><span class="toc-number">1.2.0.2.4.</span> <span class="toc-text">2.2.4 各编译阶段入口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">3. 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">3.1 总体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-DFA%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">3.2 DFA的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Token%E7%B1%BB"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">3.3 Token类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-token"><span class="toc-number">1.3.0.3.1.</span> <span class="toc-text">3.3.1 token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E6%96%87%E6%B3%95%E8%AE%BE%E5%AE%9A%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">1.3.0.3.2.</span> <span class="toc-text">3.3.2 文法设定的保存</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">4. 语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">4.1 总体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">4.2 递归下降的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-nextsym-%E7%9A%84%E5%B0%81%E8%A3%85-matchToken"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">4.2.1 nextsym()的封装: matchToken()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.0.2.2.</span> <span class="toc-text">4.2.2 子程序: &lt;非终结符&gt;()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9-node%E7%B1%BB"><span class="toc-number">1.4.0.2.3.</span> <span class="toc-text">4.2.3 语法树的结点:node类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E6%89%93%E5%8D%B0-print"><span class="toc-number">1.4.0.2.4.</span> <span class="toc-text">4.2.4 语法树的打印:print()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%B7%A6%E9%80%92%E5%BD%92%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">4.3 左递归的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E5%8F%B3%E9%80%92%E5%BD%92%E6%94%B9%E5%86%99"><span class="toc-number">1.4.0.3.1.</span> <span class="toc-text">4.3.1 右递归改写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E6%89%A9%E5%85%85%E7%9A%84BNF%E8%8C%83%E5%BC%8F"><span class="toc-number">1.4.0.3.2.</span> <span class="toc-text">4.3.2 扩充的BNF范式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E6%88%91%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.0.3.3.</span> <span class="toc-text">4.3.3 我的处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%9B%9E%E6%BA%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">4.4 回溯的处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5. 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">5.1 符号表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E7%AC%A6%E5%8F%B7Symbol"><span class="toc-number">1.5.0.1.1.</span> <span class="toc-text">5.1.1 符号Symbol</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E7%AC%A6%E5%8F%B7%E8%A1%A8SymbolTable"><span class="toc-number">1.5.0.1.2.</span> <span class="toc-text">5.1.2 符号表SymbolTable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-3-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%A0%88SymbolTableStack"><span class="toc-number">1.5.0.1.3.</span> <span class="toc-text">5.1.3 符号表栈SymbolTableStack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-4-%E5%85%A5%E6%A0%88%E6%96%B0%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.5.0.1.4.</span> <span class="toc-text">5.1.4 入栈新符号表的时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-5-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.5.0.1.5.</span> <span class="toc-text">5.1.5 添加新符号的时机</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">5.2 错误处理的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.0.2.1.</span> <span class="toc-text">5.2.1 错误记录方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-%E8%AE%B0%E5%BD%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.0.2.2.</span> <span class="toc-text">5.2.1 记录错误的接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-%E5%85%B7%E4%BD%93%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.0.2.3.</span> <span class="toc-text">5.2.2 具体错误的处理方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">6. 中间代码生成与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%AF%B9LLVM%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">6.1 对LLVM的简单理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-1-%E6%93%8D%E4%BD%9C%E6%95%B0-Value%E7%B1%BB"><span class="toc-number">1.6.0.1.1.</span> <span class="toc-text">6.1.1 操作数 Value类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BD%BF%E7%94%A8%E8%80%85-User%E7%B1%BB"><span class="toc-number">1.6.0.1.2.</span> <span class="toc-text">6.1.2 操作数使用者 User类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-3-User%E7%B1%BB%E7%BB%A7%E6%89%BFValue%E7%B1%BB"><span class="toc-number">1.6.0.1.3.</span> <span class="toc-text">6.1.3 User类继承Value类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-4-%E6%8C%87%E4%BB%A4-Instruction%E7%B1%BB"><span class="toc-number">1.6.0.1.4.</span> <span class="toc-text">6.1.4 指令 Instruction类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-5-%E7%89%B9%E6%AE%8A%E7%9A%84Value%E7%B1%BB%EF%BC%9AFunction%E5%92%8CBasicBlock%E7%B1%BB"><span class="toc-number">1.6.0.1.5.</span> <span class="toc-text">6.1.5 特殊的Value类：Function和BasicBlock类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-6-%E6%A0%B9%E8%8A%82%E7%82%B9%EF%BC%9AModule%E7%B1%BB"><span class="toc-number">1.6.0.1.6.</span> <span class="toc-text">6.1.6 根节点：Module类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">6.2 架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-1-node%E7%B1%BB%E4%BB%AC%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E8%80%85"><span class="toc-number">1.6.0.2.1.</span> <span class="toc-text">6.2.1 node类们：递归下降的具体实现者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-2-IrBuilder%E7%B1%BB%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E5%8E%82"><span class="toc-number">1.6.0.2.2.</span> <span class="toc-text">6.2.2 IrBuilder类：指令的工厂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-3-Irc%E7%B1%BB%EF%BC%9A%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.0.2.3.</span> <span class="toc-text">6.2.3 Irc类：递归下降的上下文信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-4-llvm%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.0.2.4.</span> <span class="toc-text">6.2.4 llvm元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-SSA%E5%88%9D%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">6.3 SSA初步处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-1-SSA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.0.3.1.</span> <span class="toc-text">6.3.1 SSA的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-phi%E5%BD%A2%E5%BC%8F%E7%9A%84SSA%E4%B8%8E%E9%80%83%E8%AF%BE%E5%BD%A2%E5%BC%8F%E7%9A%84SSA"><span class="toc-number">1.6.0.3.2.</span> <span class="toc-text">6.3.2 phi形式的SSA与逃课形式的SSA</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E9%80%83%E8%AF%BESSA%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.0.3.3.</span> <span class="toc-text">6.3.2 局部变量的逃课SSA实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-GEP%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">6.5 GEP指令的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-ConstExp%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">6.6 ConstExp的处理与常量传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">6.7 符号表的构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-%E5%85%B6%E4%BB%96"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">6.8 其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">7. 目标代码生成与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">7.1 架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-1-MipsBuilder%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E5%8E%82%E7%B1%BB"><span class="toc-number">1.7.0.1.1.</span> <span class="toc-text">7.1.1 MipsBuilder：指令的工厂类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-2-Mc%EF%BC%9A%E8%AE%B0%E5%BD%95llvm%E6%88%90%E5%88%86%E5%88%B0mips%E6%88%90%E5%88%86%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.0.1.2.</span> <span class="toc-text">7.1.2 Mc：记录llvm成分到mips成分的映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-3-llvm%E7%9A%84%E6%88%90%E5%88%86%E7%B1%BB%EF%BC%9Amips%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9C%BA%E6%89%80"><span class="toc-number">1.7.0.1.3.</span> <span class="toc-text">7.1.3 llvm的成分类：mips生成的主要场所</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-4-backend-instructions-Mips%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-number">1.7.0.1.4.</span> <span class="toc-text">7.1.4 backend&#x2F;instructions: Mips指令类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-5-backend-operands-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB"><span class="toc-number">1.7.0.1.5.</span> <span class="toc-text">7.1.5 backend&#x2F;operands: 操作数类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">7.2 构建流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-1-%E6%9E%84%E5%BB%BA-data%E6%AE%B5"><span class="toc-number">1.7.0.2.1.</span> <span class="toc-text">7.2.1 构建.data段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-%E4%B8%BA%E6%89%80%E6%9C%89Block%E5%92%8CFunction%E5%88%9B%E5%BB%BAMips%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E6%98%A0%E5%B0%84%E5%88%B0llvm%E7%9A%84%E7%9B%B8%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.0.2.2.</span> <span class="toc-text">7.2.2 为所有Block和Function创建Mips对象，并映射到llvm的相应对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-3-%E9%81%8D%E5%8E%86llvm%E7%9A%84%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.0.2.3.</span> <span class="toc-text">7.2.3 遍历llvm的树形结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">7.3 存储管理的翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-1-Call%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.7.0.3.1.</span> <span class="toc-text">7.3.1 Call：参数传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-MipsFunction%EF%BC%9A%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA"><span class="toc-number">1.7.0.3.2.</span> <span class="toc-text">7.3.2 MipsFunction：保存现场</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-3-MipsRet%EF%BC%9A%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA"><span class="toc-number">1.7.0.3.3.</span> <span class="toc-text">7.3.3 MipsRet：恢复现场</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/28/dl-bugs-1/" title="关于Conda在install时爆出段错误的解决办法"><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于Conda在install时爆出段错误的解决办法"/></a><div class="content"><a class="title" href="/2024/02/28/dl-bugs-1/" title="关于Conda在install时爆出段错误的解决办法">关于Conda在install时爆出段错误的解决办法</a><time datetime="2024-02-28T14:56:25.202Z" title="发表于 2024-02-28 22:56:25">2024-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/20/compiler-report/" title="BUAA2023秋编译原理 实验文档"><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023秋编译原理 实验文档"/></a><div class="content"><a class="title" href="/2023/12/20/compiler-report/" title="BUAA2023秋编译原理 实验文档">BUAA2023秋编译原理 实验文档</a><time datetime="2023-12-20T15:59:23.419Z" title="发表于 2023-12-20 23:59:23">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/20/compiler-opt-report/" title="BUAA2023秋编译原理 优化文档"><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023秋编译原理 优化文档"/></a><div class="content"><a class="title" href="/2023/12/20/compiler-opt-report/" title="BUAA2023秋编译原理 优化文档">BUAA2023秋编译原理 优化文档</a><time datetime="2023-12-20T15:59:23.415Z" title="发表于 2023-12-20 23:59:23">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/pic-1/" title="网络趣味图片合集1"><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络趣味图片合集1"/></a><div class="content"><a class="title" href="/2023/08/20/pic-1/" title="网络趣味图片合集1">网络趣味图片合集1</a><time datetime="2023-08-19T16:47:45.984Z" title="发表于 2023-08-20 00:47:45">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/OSlab-report-3/" title="BUAA2023春OS课程LAB3实验报告"><img src="https://arksuzuran.oss-cn-beijing.aliyuncs.com/img/md_img/default_cover_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA2023春OS课程LAB3实验报告"/></a><div class="content"><a class="title" href="/2023/08/20/OSlab-report-3/" title="BUAA2023春OS课程LAB3实验报告">BUAA2023春OS课程LAB3实验报告</a><time datetime="2023-08-19T16:45:27.371Z" title="发表于 2023-08-20 00:45:27">2023-08-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By H1kari</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>